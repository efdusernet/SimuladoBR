<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulado — Questão</title>
  <!-- Controlled Logging System (must load before other scripts) -->
  <script src="/utils/logger.js"></script>
  <!-- CSRF Protection (adds X-CSRF-Token for /api requests) -->
  <script src="/utils/csrf.js"></script>
  <script src="/utils/auth.js"></script>
  <!-- Support chat widget (served via backend /chat proxy) -->
  <!-- Prefer CSS minificado em dist quando disponível; mantém original como fallback -->
  <link rel="stylesheet" href="../dist/styles.css" />
  <link rel="stylesheet" href="../styles.css" />
  <style>
    .ans-correct{ border:1px solid #16a34a; background:#ecfdf5; }
    .ans-wrong{ border:1px solid #dc2626; background:#fef2f2; }
    .opt-expl{ margin-top:6px; font-size:12px; color:#475569; line-height:1.35; padding:6px 8px; background:#ffffff; border-left:3px solid #cbd5e1; border-radius:6px; }
    .opt-expl strong{ font-weight:600; color:#334155; }
    @keyframes bump { 0%{ transform:scale(1); } 45%{ transform:scale(1.03); } 100%{ transform:scale(1); } }
    .btn-bump{ animation:bump 220ms ease-out; }
    @keyframes revealCorrect { 0%{ transform:translateY(0); } 35%{ transform:translateY(-2px); } 100%{ transform:translateY(0); } }
    .reveal-correct{ animation:revealCorrect 260ms ease-out; }
    /* Estado do botão de marcar questão */
    #bmark.mark-active{
      border-color:#f59e0b; /* amber-500 */
      background:#fffbeb;   /* amber-50 */
      color:#92400e;        /* amber-800 */
    }

    /* Feedback thumbs colors */
    #likeBtn[aria-pressed="true"]{ color:#2563eb; }
    #dislikeBtn[aria-pressed="true"]{ color:#fca5a5; }
  </style>
</head>
<body>
  <header id="userHeader" style="display:none; padding:12px; background:#f4f4f4; border-bottom:1px solid #ddd;">
    <div style="max-width:900px;margin:0 auto;">Bem-vindo, <strong id="userNameHeader"></strong></div>
  </header>
  
  <div id="toast" class="toast" aria-live="polite" style="display:none"></div>

  <main class="exam-container" role="main" style="margin-top:8px;">
    <header class="exam-header" style="margin-bottom:8px; padding:4px 0;">
      <div class="header-left">
        <div class="resource-Buttons" id="resource-buttons" aria-live="polite">
          <div class="inline-flex">
            <button class="rounded-l-sm border border-gray-200 px-3 py-2 font-medium text-gray-700 transition-colors hover:bg-gray-50 hover:text-gray-900 focus:z-10 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-white focus:outline-none disabled:pointer-events-auto disabled:opacity-50" id="bmark" type="button">
              <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path d="M6 2h12c.55 0 1 .45 1 1v17l-7-3-7 3V3c0-.55.45-1 1-1z"></path>
              </svg>
              Marcar questão
            </button>

            <button class="-ml-px border border-gray-200 px-3 py-2 font-medium text-gray-700 transition-colors hover:bg-gray-50 hover:text-gray-900 focus:z-10 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-white focus:outline-none disabled:pointer-events-auto disabled:opacity-50" id="bgrid" type="button">
              <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="3" y="3" width="4" height="4" rx="0.8"></rect>
                <rect x="10" y="3" width="4" height="4" rx="0.8"></rect>
                <rect x="17" y="3" width="4" height="4" rx="0.8"></rect>
                <rect x="3" y="10" width="4" height="4" rx="0.8"></rect>
                <rect x="10" y="10" width="4" height="4" rx="0.8"></rect>
                <rect x="17" y="10" width="4" height="4" rx="0.8"></rect>
                <rect x="3" y="17" width="4" height="4" rx="0.8"></rect>
                <rect x="10" y="17" width="4" height="4" rx="0.8"></rect>
                <rect x="17" y="17" width="4" height="4" rx="0.8"></rect>
              </svg>
              Grid de questões
            </button>

            <button class="-ml-px rounded-r-sm border border-gray-200 px-3 py-2 font-medium text-gray-700 transition-colors hover:bg-gray-50 hover:text-gray-900 focus:z-10 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-white focus:outline-none disabled:pointer-events-auto disabled:opacity-50" id="bcalc" type="button" disabled>
              <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path d="M7 2h10a2 2 0 012 2v16a2 2 0 01-2 2H7a2 2 0 01-2-2V4a2 2 0 012-2zm0 2v4h10V4H7zm1 7h2v2H8v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zM8 15h2v2H8v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z"></path>
              </svg>
              Calc
            </button>
          </div>
        </div>
      </div>

      <div class="header-center" id="centerHeader">
        <div class="knowledge-area" id="knowledgeArea" aria-live="polite">Quiz</div>
        <div class="timer" id="timerBox" aria-live="polite" title="Tempo decorrido">
          <span id="timerDisplay">00:00</span>
        </div>
      </div>

      <div class="header-right controls">
        <div class="font-control">
          <button id="fontToggle" class="icon-btn" aria-expanded="false" aria-controls="fontSlider" title="Ajustar tamanho da fonte">Aa</button>
          <div id="fontSlider" class="font-slider" hidden>
            <label for="fontRange">Tamanho da fonte</label>
            <input id="fontRange" type="range" min="12" max="24" value="16" />
          </div>
        </div>
      </div>
    </header>

    

    <section class="question-panel" aria-labelledby="questionNumber">
      <div class="meta-row" style="display:flex; align-items:center; gap:10px;">
        <div id="qStatus" class="q-status">Questão <span id="questionNumber">1</span> / <span id="totalQuestions">1</span></div>
        <span id="questionIdDisplay" style="margin-left:auto; font-size:14px; color:#555;"></span>
        <div class="feedback-buttons">
          <button id="bhighlight" class="icon-btn" type="button" title="Destacar/Remover destaque">
            <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M14 3.2L3.2 14 2 22l8-1.2L22.8 10 14 3.2z"></path>
              <path d="M2 22h10v2H2z"></path>
            </svg>
            Destacar questão
          </button>
          <button id="hintBtn" class="icon-btn" type="button" title="Mostrar dica" aria-label="Mostrar dica">
            <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M12 2a7 7 0 00-7 7c0 3.06 1.92 5.66 4.6 6.6l.4 2.4h4l.4-2.4A7 7 0 0019 9a7 7 0 00-7-7zm-1 16h2v2h-2v-2zm1-14a5 5 0 00-5 5c0 2.2 1.42 4.08 3.4 4.74L10.6 15h2.8l-.8-1.26A5 5 0 0017 9a5 5 0 00-5-5z" fill="currentColor"></path>
            </svg>
            Dica
          </button>
          <button id="likeBtn" class="icon-like" aria-pressed="false" title="Gostei" aria-label="Gostei">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true" focusable="false">
              <path d="M2 21h4V9H2v12zm20-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L13 1 6.59 7.41C6.22 7.78 6 8.3 6 8.83V19c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l2.02-4.71c.09-.23.14-.47.14-.72V10z" fill="currentColor"/>
            </svg>
          </button>
          <button id="dislikeBtn" class="icon-dislike" aria-pressed="false" title="Não gostei" aria-label="Não gostei">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true" focusable="false">
              <path d="M22 3h-4v12h4V3zM2 14c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L11 23l6.41-6.41c.37-.37.59-.89.59-1.42V5c0-1.1-.9-2-2-2H7c-.83 0-1.54.5-1.84 1.22L3.14 8.93C3.05 9.16 3 9.4 3 9.65V14H2z" fill="currentColor"/>
            </svg>
          </button>
        </div>
      </div>

      <article class="question-content" id="questionContent">
        <p id="questionText" class="question-text">Carregando pergunta...</p>
        <div id="questionImageWrapper" style="display:none; margin:12px 0 16px; text-align:center;"></div>

        <form id="answersForm" class="answers-form" autocomplete="off" novalidate>
          <div id="answersContainer"></div>
        </form>

        <div class="actions-row" style="display:flex; align-items:center; gap:8px;">
          <button id="finishExamBtn" type="button" class="primary-btn" style="background:#FA8072;color:#fff; margin-right:auto;">Finalizar exame</button>
          <button id="backBtn" class="primary-btn" style="display:none;margin-right:8px;">Voltar</button>
          <button id="checkAnswerBtn" type="button" class="primary-btn">Conferir resposta</button>
          <button id="continueBtn" class="primary-btn">Continuar</button>
        </div>
        <div id="hintContainer" style="display:none; margin-top:12px; padding:10px; border:1px solid #e2e8f0; border-radius:6px; background:#f8fafc; color:#334155; font-size:14px; line-height:1.5;"></div>
      </article>
    </section>
  </main>
  <!-- define session vars required by exam pages -->
  <script>
    try {
      // Descobrir o blueprint do exame (se definido pelo setup ou pela API)
      let bp = null;
      try { const raw = localStorage.getItem('examBlueprint'); bp = raw ? JSON.parse(raw) : null; } catch(_) { bp = null; }

      // Defaults (PMP): 180 questões, 230 minutos
      const _tempoExame = (bp && Number(bp.duracaoMinutos)) ? Number(bp.duracaoMinutos) : 230; // em minutos
      const _FullExam = (bp && Number(bp.numeroQuestoes)) ? Number(bp.numeroQuestoes) : 180;

      sessionStorage.setItem('tempoExame', JSON.stringify(_tempoExame));
      sessionStorage.setItem('FullExam', JSON.stringify(_FullExam));
      // também expor como variáveis globais numéricas para uso imediato no script
      window.tempoExame = _tempoExame;
      window.FullExam = _FullExam;
      // Expor algumas flags do blueprint (usadas pelo script)
      window.ExamMultiplaSelecao = !!(bp && bp.multiplaSelecao);
      window.ExamCheckpoints = (bp && bp.pausas && Array.isArray(bp.pausas.checkpoints)) ? bp.pausas.checkpoints.slice() : [60,120];
    } catch (e) {
      logger.warn('Falha ao definir variáveis de sessão:', e);
    }
  </script>
  <!-- Exibir imagem da questão (campo imagem_url / imagemUrl) abaixo do enunciado -->
  <script>
    (function(){
      function resolveQuestions(){
        try {
          if (Array.isArray(window.QUESTIONS)) return window.QUESTIONS;
          const sid = window.currentSessionId || null; if (!sid) return [];
          const raw = localStorage.getItem(`questions_${sid}`);
          if (!raw) return [];
          const arr = JSON.parse(raw); return Array.isArray(arr)? arr : [];
        } catch(_) { return []; }
      }
      function currentIndex(){
        try { const el = document.getElementById('questionNumber'); const n = Number((el&&el.textContent||'').trim()); return Number.isFinite(n)? n-1 : 0; } catch(_) { return 0; }
      }
      function buildSrc(str){
        if (!str) return null;
        const s = String(str).trim();
        if (!s) return null;
        if (/^data:image\//i.test(s)) return s;
        if (/^https?:\/\//i.test(s) || s.startsWith('/')) return s;
        if (/^data:/i.test(s)) return s;
        if (/^[A-Za-z0-9+/=]+$/.test(s) && s.length > 100) return 'data:image/png;base64,' + s;
        return s;
      }
      function renderImage(){
        try {
          const wrap = document.getElementById('questionImageWrapper'); if (!wrap) return;
          const qs = resolveQuestions(); const idx = currentIndex(); const q = (idx>=0 && idx < qs.length)? qs[idx] : null;
          const raw = q && (q.imagemUrl || q.imagem_url || q.imageUrl || q.image_url) || '';
          let src = buildSrc(raw);
          // Fallback: if image field is empty, try to find inline <img> inside the question text
          if (!src) {
            try {
              const qt = document.getElementById('questionText');
              const inlineImg = qt ? qt.querySelector('img') : null;
              const inlineSrc = inlineImg ? inlineImg.getAttribute('src') : null;
              if (inlineSrc) src = buildSrc(inlineSrc);
            } catch(_) { /* ignore */ }
          }
          // Fallback 2: parse descricao/text HTML for an <img src="...">
          if (!src && q) {
            try {
              const html = String(q.descricao || q.text || '').trim();
              const m = html.match(/<img[^>]+src=["']([^"']+)["']/i);
              if (m && m[1]) src = buildSrc(m[1]);
            } catch(_) { /* ignore */ }
          }
          // Fallback 3: parse explicacao HTML for an <img src="...">
          if (!src && q && q.explicacao) {
            try {
              const html2 = String(q.explicacao || '').trim();
              const m2 = html2.match(/<img[^>]+src=["']([^"']+)["']/i);
              if (m2 && m2[1]) src = buildSrc(m2[1]);
            } catch(_) { /* ignore */ }
          }
          try { logger.debug('[examSingle] renderImage idx', idx, 'id', q && q.id, 'resolved src?', !!src); } catch(_){ }
          if (!src){ wrap.style.display='none'; wrap.innerHTML=''; return; }
          const img = document.createElement('img');
          img.src = src; img.alt='Imagem ilustrativa da questão'; img.style.maxWidth='680px'; img.style.width='100%'; img.style.height='auto'; img.style.border='1px solid #e2e8f0'; img.style.background='#fff'; img.style.borderRadius='6px'; img.style.boxShadow='0 1px 2px rgba(0,0,0,0.06)'; img.decoding='async'; img.loading='lazy';
          wrap.innerHTML=''; wrap.appendChild(img); wrap.style.display='block';
        } catch(_){}
      }
      document.addEventListener('exam:question-index-changed', renderImage);
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ()=>setTimeout(renderImage,120)); else setTimeout(renderImage,120);
    })();
  </script>

  <!-- Backend configuration (must be set before script.js and script_exam.js) -->
  <script>
    window.SIMULADOS_CONFIG = window.SIMULADOS_CONFIG || {};
    window.SIMULADOS_CONFIG.BACKEND_BASE = window.SIMULADOS_CONFIG.BACKEND_BASE || (window.location && window.location.origin) || 'http://app.localhost:3000';
  </script>

  <!-- registration/session script must run before exam script; prefer non-minified for safety with removed #status/#autosaveIndicator -->
  <script src="../script.js"></script>
  <!-- Shared exam cleanup utilities -->
  <script src="../components/examCleanup.js"></script>
  <!-- Intercept selection to bypass filters when count=180 and fallback ignoring exam_type if needed -->
  <script>
    (function(){
      try {
        const origFetch = window.fetch.bind(window);
        window.fetch = async function(input, init){
          try {
            const url = (typeof input === 'string') ? input : (input && input.url) || '';
            if (url && url.endsWith('/api/exams/select') && init && typeof init === 'object' && String(init.method||'').toUpperCase() === 'POST' && init.body) {
              let body = null; try { body = JSON.parse(init.body); } catch(_){ body = null; }
              const cnt = body && Number(body.count);
              const onlyCount = !!(body && body.onlyCount === true);
              // Injeta flag onlyNew se usuário premium e selecionado no setup
              try {
                const premium = localStorage.getItem('BloqueioAtivado') !== 'true';
                const onlyNewFlag = premium && localStorage.getItem('examOnlyNewQuestions') === 'true';
                if (onlyNewFlag && body && !body.onlyNew) {
                  body.onlyNew = true;
                  init.body = JSON.stringify(body);
                }
              } catch(e){}
              if (cnt === 180 && body) {
                delete body.areas; delete body.grupos; delete body.dominios; delete body.categorias;
                init.body = JSON.stringify(body);
              }
              const resp = await origFetch(input, init);
              if (resp && resp.status === 400 && cnt === 180) {
                let available = null;
                try { const t = await resp.clone().text(); const j = t ? JSON.parse(t) : null; if (j && typeof j.available === 'number') available = j.available; } catch(_){}
                if (available === 0) {
                  const headers = new Headers(init.headers || {});
                  headers.delete('X-Exam-Type');
                  return await origFetch(input, { method: 'POST', headers, body: JSON.stringify({ count: cnt, ignoreExamType: true, onlyCount }) });
                }
              }
              return resp;
            }
          } catch(_){ }
          return origFetch(input, init);
        };
      } catch(_){ }
    })();
  </script>

  <!-- Modal de Grid de Questões (reaproveita grid.html) -->
  <div id="gridModal" class="modal" aria-hidden="true" style="display:none;">
    <div class="modal-content" style="width: min(100%, 96vw); max-width: 1200px; height: min(88vh, 900px); display:flex; flex-direction:column; padding: 0;">
      <div style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid #ddd; background:#f7f7f7;">
        <h2 style="margin:0; font-size:1rem;">Grid de Questões</h2>
        <button id="closeGridModal" class="secondary-btn" type="button" style="margin-left:auto;">Fechar</button>
      </div>
      <iframe id="gridFrame" title="Grid de Questões" src="" style="flex:1; width:100%; height:100%; border:0; background:white;"></iframe>
    </div>
  </div>

  <script>
    (function(){
      function openGrid(){
        try {
          try {
            const sid = window.currentSessionId || localStorage.getItem('currentSessionId') || localStorage.getItem('tempSessionId');
            const totalEl = document.getElementById('totalQuestions');
            const total = totalEl ? Number((totalEl.textContent || '').trim()) : NaN;
            if (!sid || !(Number.isFinite(total) && total > 0)) {
              try { if (typeof showToast === 'function') showToast('Inicie o simulado para ver o grid.'); } catch(_){ }
              return;
            }
          } catch(_){ }
          try { if (typeof window.captureCurrentAnswerSnapshot === 'function') window.captureCurrentAnswerSnapshot(); } catch(_){ }
          const modal = document.getElementById('gridModal');
          const frame = document.getElementById('gridFrame');
          if (!modal || !frame) return;
          frame.src = '/pages/grid.html?t=' + Date.now();
          modal.style.display = '';
          modal.setAttribute('aria-hidden','false');
        } catch(e){}
      }
      function closeGrid(){
        try {
          const modal = document.getElementById('gridModal');
          const frame = document.getElementById('gridFrame');
          if (!modal) return;
          modal.style.display = 'none';
          modal.setAttribute('aria-hidden','true');
          if (frame) frame.src = '';
        } catch(e){}
      }
      function attachGridHandlers(){
        const btn = document.getElementById('bgrid');
        if (btn) btn.addEventListener('click', openGrid);
        const close = document.getElementById('closeGridModal');
        if (close) close.addEventListener('click', closeGrid);
        window.addEventListener('keydown', (ev)=>{ if (ev.key === 'Escape') closeGrid(); });
      }
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attachGridHandlers); else attachGridHandlers();
    })();
  </script>

  <!-- Marcar questão: salva/desmarca em localStorage (usado pelo grid.html) -->
  <script>
    (function(){
      function mapSpanIdToLetter(id){
        if(!id) return null;
        const m = id.match(/^opt(\d+)$/);
        if(!m) return null;
        const n = parseInt(m[1], 10);
        const zeroBased = !!document.getElementById('opt0');
        if (zeroBased) { if (n >= 0 && n <= 3) return ['A','B','C','D'][n]; }
        else { if (n >= 1 && n <= 4) return String.fromCharCode(64 + n); }
        return null;
      }
      function getSelectedLetter(){
        const checked = document.querySelector('input[name="answer"]:checked');
        if(!checked) return null;
        let span = checked.nextElementSibling;
        if (!span || !(span.classList && span.classList.contains('option-text'))){
          const label = checked.closest && checked.closest('label');
          if (label) span = label.querySelector('.option-text');
        }
        const sid = span && span.id || null;
        let letter = mapSpanIdToLetter(sid);
        if (!letter){
          const idx = Number(checked.value);
          if (Number.isInteger(idx) && idx >= 0 && idx <= 3) letter = ['A','B','C','D'][idx];
        }
        return letter;
      }
      function getCurrentIdxViaDom(){
        try { const el = document.getElementById('questionNumber'); if (!el) return null; const n = Number((el.textContent||'').trim()); return (Number.isFinite(n) && n >= 1) ? n - 1 : null; } catch(e){ return null; }
      }
      function getCurrentIdxFromProgress(){
        try{
          const sid = window.currentSessionId || null;
          const key = sid ? `progress_${sid}` : null;
          if(key){ const raw = localStorage.getItem(key); if(raw){ const obj = JSON.parse(raw); if (obj && typeof obj.currentIdx === 'number') return obj.currentIdx; } }
        }catch(e){}
        return getCurrentIdxViaDom();
      }
      function readMarkedList(){
        const sid = window.currentSessionId || '';
        const key = sid ? `questoesMarcadas_${sid}` : 'questoesMarcadas';
        try{ const raw = localStorage.getItem(key); if(!raw) return { key, list: [] }; const arr = JSON.parse(raw); return { key, list: Array.isArray(arr) ? arr : [] }; }catch(e){ return { key, list: [] }; }
      }
      function writeMarkedList(key, list){ try{ localStorage.setItem(key, JSON.stringify(list)); }catch(e){} }

      function isCurrentQuestionMarked(){
        try{
          let curIdx = getCurrentIdxFromProgress();
          if (curIdx === null || curIdx === undefined) curIdx = getCurrentIdxViaDom();
          if (typeof curIdx !== 'number') return false;
          const { list } = readMarkedList();
          return Array.isArray(list) && list.some(e => e && typeof e.currentIdx === 'number' && e.currentIdx === curIdx);
        }catch(_){ return false; }
      }

      function syncMarkButtonState(){
        const btn = document.getElementById('bmark');
        if (!btn) return;
        const marked = isCurrentQuestionMarked();
        btn.classList.toggle('mark-active', marked);
        btn.setAttribute('aria-pressed', marked ? 'true' : 'false');
        const label = marked ? 'Desmarcar questão' : 'Marcar questão';
        const textNodes = Array.from(btn.childNodes).filter(n => n.nodeType === Node.TEXT_NODE);
        if (textNodes.length){
          textNodes[textNodes.length - 1].textContent = ' ' + label;
        } else {
          btn.textContent = label;
        }
      }

      function hasActiveSession(){
        try {
          const sid = window.currentSessionId || localStorage.getItem('currentSessionId') || localStorage.getItem('tempSessionId');
          if (!sid) return false;
          const totalEl = document.getElementById('totalQuestions');
          const total = totalEl ? Number((totalEl.textContent || '').trim()) : NaN;
          return Number.isFinite(total) && total > 0;
        } catch(_){ return false; }
      }

      function syncControlsEnabled(){
        const enabled = hasActiveSession();
        const bmark = document.getElementById('bmark');
        const bgrid = document.getElementById('bgrid');
        const bcalc = document.getElementById('bcalc');
        if (bmark) bmark.disabled = !enabled;
        if (bgrid) bgrid.disabled = !enabled;
        if (bcalc) bcalc.disabled = !enabled || !isCurrentQuestionMath();
        if (enabled) syncMarkButtonState();
      }

      function isCurrentQuestionMath(){
        try{
          let curIdx = getCurrentIdxFromProgress();
          if (curIdx === null || curIdx === undefined) curIdx = getCurrentIdxViaDom();
          if (typeof curIdx !== 'number') return false;
          const arr = Array.isArray(window.QUESTIONS) ? window.QUESTIONS : [];
          const q = (curIdx >= 0 && curIdx < arr.length) ? arr[curIdx] : null;
          return !!(q && q.isMath === true);
        }catch(_){ return false; }
      }

      function onMarkClick(){
        try{
          const letter = getSelectedLetter();
          let curIdx = getCurrentIdxFromProgress(); if (curIdx === null || curIdx === undefined) curIdx = getCurrentIdxViaDom();
          const questionNumber = (typeof curIdx === 'number') ? (curIdx + 1) : null;
          const { key, list } = readMarkedList();
          if (typeof curIdx === 'number'){
            const i = list.findIndex(e => e && typeof e.currentIdx === 'number' && e.currentIdx === curIdx);
            if (i >= 0) {
              list.splice(i, 1);
              writeMarkedList(key, list);
              syncMarkButtonState();
              try { if (typeof showToast === 'function') showToast(`Questão ${questionNumber || ''} desmarcada.`); } catch(_){ }
            } else {
              const entry = { currentIdx: curIdx, questionNumber, letter: letter || null, savedAt: new Date().toISOString() };
              list.push(entry);
              writeMarkedList(key, list);
              syncMarkButtonState();
              try { if (typeof showToast === 'function') showToast(`Questão ${questionNumber || ''} marcada${letter ? ' ('+letter+')' : ''}.`); } catch(_){ }
            }
          } else {
            const entry = { currentIdx: null, questionNumber: null, letter: letter || null, savedAt: new Date().toISOString() };
            list.push(entry);
            writeMarkedList(key, list);
            syncMarkButtonState();
            try { if (typeof showToast === 'function') showToast(`Questão marcada${letter ? ' ('+letter+')' : ''}.`); } catch(_){ }
          }
        } catch(err){ try { logger.warn('Falha ao salvar marcação da questão:', err); } catch(_){ } }
      }
      function onAnswerChanged(){
        try {
          const letter = getSelectedLetter();
          let curIdx = getCurrentIdxFromProgress(); if (curIdx === null || curIdx === undefined) curIdx = getCurrentIdxViaDom();
          const { key, list } = readMarkedList();
          if (typeof curIdx === 'number' && Array.isArray(list)){
            const i = list.findIndex(e => e && typeof e.currentIdx === 'number' && e.currentIdx === curIdx);
            if (i >= 0){ list[i].letter = letter || null; list[i].savedAt = new Date().toISOString(); writeMarkedList(key, list); }
          }
          syncMarkButtonState();
          try { if (typeof window.__syncProgressIdxToLabel === 'function') window.__syncProgressIdxToLabel(); } catch(_){ }
        } catch(e) { /* noop */ }
      }
      function attach(){
        const btn = document.getElementById('bmark');
        if (btn) btn.addEventListener('click', onMarkClick);

        try {
          const bcalc = document.getElementById('bcalc');
          if (bcalc) bcalc.addEventListener('click', ()=>{
            try {
              if (bcalc.disabled) return;
              if (window.Calculator && typeof window.Calculator.open === 'function') window.Calculator.open();
            } catch(_){ }
          });
        } catch(_){ }
        try {
          const form = document.getElementById('answersForm');
          if (form){
            form.addEventListener('change', (ev)=>{
              const t = ev && ev.target;
              if (t && t.matches && t.matches('input[name="answer"]')) onAnswerChanged();
            });
          }
        } catch(_) {}

        try {
          const qn = document.getElementById('questionNumber');
          if (qn && 'MutationObserver' in window){
            const obs = new MutationObserver(()=>{ syncControlsEnabled(); });
            obs.observe(qn, { childList:true, characterData:true, subtree:true });
          }
        } catch(_) {}

        try {
          const tq = document.getElementById('totalQuestions');
          if (tq && 'MutationObserver' in window){
            const obs2 = new MutationObserver(()=>{ syncControlsEnabled(); });
            obs2.observe(tq, { childList:true, characterData:true, subtree:true });
          }
        } catch(_) {}

        // Habilita assim que a sessão for criada/carregada
        try {
          let tries = 0;
          const t = setInterval(()=>{
            tries += 1;
            syncControlsEnabled();
            if (hasActiveSession() || tries > 80) clearInterval(t);
          }, 250);
        } catch(_) {}

        syncControlsEnabled();
      }
      if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', attach); } else { attach(); }
    })();
  </script>
  <!-- DOMPurify for XSS protection -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
  <!-- Sanitization utilities -->
  <script src="../utils/sanitize.js"></script>
  <!-- MatchColumns (drag-and-drop question type) -->
  <script src="../utils/matchColumns.js?v=20260116_3"></script>
  <!-- Calculator modal (enabled only for math questions) -->
  <script src="../components/calculator.js?v=20260206_01"></script>
  <!-- Prefer non-minified script for image field support and diagnostics -->
  <script src="../script_exam.js?v=20260206_01"></script>
  <!-- (Optional) Keep build script disabled for now; uncomment if needed -->
  <!-- <script src="../assets/build/script_exam.js"></script> -->

  <!-- initialize global QtdQuestoes and timer behavior -->
  <script>
    (function(){
      try {
        // Session guard: require non-guest identity; else send to registration entrypoint
        try {
          const token = localStorage.getItem('sessionToken') || '';
          const hasIdentity = !!(localStorage.getItem('userId') || localStorage.getItem('nomeUsuario') || localStorage.getItem('nome'));
          if ((!token && !hasIdentity) || ((token && token.endsWith('#')) && !hasIdentity)) {
            try { sessionStorage.setItem('postLoginRedirect', window.location.href); } catch(_){ }
            window.location.assign('/login?redirect=' + encodeURIComponent(window.location.href));
            return;
          }
        } catch(e) {}

        // Read chosen question count from localStorage (set by examSetup)
        let q = null;
        try { q = localStorage.getItem('examQuestionCount'); } catch(e) { q = null; }
        let parsed = q ? Number(q) : null;
        // fallback to FullExam if not set
        const full = (typeof window.FullExam === 'number') ? window.FullExam : (sessionStorage.getItem('FullExam') ? JSON.parse(sessionStorage.getItem('FullExam')) : null);
        // Enforce plan rules (avoid stale localStorage values)
        try {
          const bloqueado = (localStorage.getItem('BloqueioAtivado') === 'true');
          if (bloqueado) {
            // Free users: only 25 or 30
            const n = (parsed && !isNaN(parsed)) ? Number(parsed) : 0;
            parsed = (n >= 30) ? 30 : 25;
          } else {
            // Premium: keep within 15..FullExam
            const fullNum = (typeof window.FullExam === 'number') ? window.FullExam : (sessionStorage.getItem('FullExam') ? JSON.parse(sessionStorage.getItem('FullExam')) : null);
            const max = Number(fullNum) || 180;
            const n = (parsed && !isNaN(parsed)) ? Number(parsed) : 0;
            if (n > 0) parsed = Math.max(15, Math.min(max, n));
          }
        } catch(_){ }

        const qtd = (parsed && !isNaN(parsed)) ? parsed : 0;
        // Guard: se não houver quantidade definida pelo setup e não vier com startExam, encaminhar para a configuração
        const shouldStart = (sessionStorage.getItem('startExam') === 'true');
        if (!qtd && !shouldStart) {
          window.location.assign('/pages/examSetup.html');
          return;
        }
        const finalQtd = qtd || (full || 0);
        // expose as global numeric
        window.QtdQuestoes = Number(finalQtd);
        // update totalQuestions display on the exam page to reflect selection
        try {
          const totalEl = document.getElementById('totalQuestions');
          if (totalEl) totalEl.textContent = String(window.QtdQuestoes);
        } catch(e) { logger.warn('update totalQuestions failed', e); }

        // Confirmação de exame completo (180) é tratada apenas na examSetup. Aqui iniciamos normalmente.

        // helper to format seconds to MM:SS or H:MM:SS if large
        function fmtSeconds(s){
          s = Math.max(0, Math.floor(s));
          if (s >= 3600) {
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60).toString().padStart(2,'0');
            const sec = (s % 60).toString().padStart(2,'0');
            return `${h}:${m}:${sec}`;
          }
          const m = Math.floor(s/60).toString().padStart(2,'0');
          const sec = (s % 60).toString().padStart(2,'0');
          return `${m}:${sec}`;
        }

        // compute total seconds proportional to quantidade selecionada:
        // 180 questões equivalem a 230 minutos => segundos = (QtdQuestoes / 180) * 230(min) * 60
        function computeSeconds() {
          const tempo = (typeof window.tempoExame === 'number') ? window.tempoExame : (sessionStorage.getItem('tempoExame') ? JSON.parse(sessionStorage.getItem('tempoExame')) : null); // minutos do exame completo
          const fullNum = (typeof window.FullExam === 'number') ? window.FullExam : (sessionStorage.getItem('FullExam') ? JSON.parse(sessionStorage.getItem('FullExam')) : null);
          const qtdNum = Number(window.QtdQuestoes) || 0;
          if (!tempo || !fullNum || !qtdNum) return 0;
          const totalMinutes = (qtdNum * tempo) / fullNum; // minutos proporcionais
          const seconds = totalMinutes * 60;
          return Math.max(0, Math.round(seconds));
        }

        // countdown state
        let _timerInterval = null;

        function startCountdown() {
          try {
            if (_timerInterval) return; // already running
            // allow resuming from persisted remaining seconds if available
            let remaining = computeSeconds();
            try {
              const progRaw = (window.currentSessionId && localStorage.getItem(`progress_${window.currentSessionId}`)) || null;
              if (progRaw) {
                const prog = JSON.parse(progRaw);
                if (prog && typeof prog === 'object' && prog.remainingSeconds !== undefined && prog.remainingSeconds !== null) {
                  remaining = Number(prog.remainingSeconds) || remaining;
                }
              }
            } catch(e) { /* ignore */ }
            const display = document.getElementById('timerDisplay');
            if (!display) return;
            display.textContent = fmtSeconds(remaining);
            _timerInterval = setInterval(() => {
              remaining -= 1;
              if (remaining <= 0) {
                display.textContent = fmtSeconds(0);
                clearInterval(_timerInterval);
                _timerInterval = null;
                try { alert('Tempo esgotado.'); } catch(e){}
                // Desabilita ações de continuação imediatamente
                try {
                  const cont = document.getElementById('continueBtn');
                  if (cont) { cont.disabled = true; cont.setAttribute('aria-disabled','true'); cont.style.opacity = '0.6'; }
                  const form = document.getElementById('answersForm');
                  if (form) { Array.from(form.querySelectorAll('input,button,select,textarea')).forEach(el=>{ el.disabled = true; }); }
                } catch(_){ }
                // Limpeza e redirecionamento para configuração do exame (shared utility)
                try {
                  if (typeof window.clearExamDataShared === 'function') { window.clearExamDataShared(); }
                  else if (typeof clearExamData === 'function') { clearExamData(); }
                  window.location.assign('/pages/examSetup.html');
                } catch(_){ window.location.assign('/pages/examSetup.html'); }
                return;
              }
              display.textContent = fmtSeconds(remaining);
              // persist remaining seconds for resume
              try {
                if (window.currentSessionId) {
                  const key = `progress_${window.currentSessionId}`;
                  const cur = JSON.parse(localStorage.getItem(key) || '{}') || {};
                  cur.remainingSeconds = remaining;
                  localStorage.setItem(key, JSON.stringify(cur));
                  localStorage.setItem(`${key}_savedAt`, new Date().toISOString());
                }
              } catch(e) {}
            }, 1000);
          } catch (e) { logger.warn('startCountdown error', e); }
        }

        // Auto-start if the user clicked "Iniciar Exame" (examSetup set sessionStorage.startExam = 'true')
        if (shouldStart) {
          // clear flag and begin
          try { sessionStorage.removeItem('startExam'); } catch(e){}
          startCountdown();
        }

        // Also expose start function globally so other UI can trigger it
        window.startExamCountdown = startCountdown;

      } catch (e) { logger.warn('Init exam timer error', e); }
    })();
  </script>

  <!-- Registration modal (copied from index.html/modal) -->
  <!-- Modal de confirmação para finalizar exame (unificado) -->
  <div id="finishConfirmModal" class="modal" aria-hidden="true" style="display:none;">
    <div class="modal-content" style="max-width:600px; padding:20px; text-align:center;">
      <p style="margin:0 0 16px 0; font-size:16px; line-height:1.5;">
        <strong>Deseja mesmo encerrar o exame?</strong><br>
        Você respondeu <strong id="completionPercent">0%</strong> das questões deste exame.<br>
        Esta tentativa <strong>não será gravada</strong> na base de dados de exames realizados.<br><br>
        Deseja mesmo sair?
      </p>
      <div style="display:flex; gap:10px; justify-content:center; margin-top:14px;">
        <button id="finishConfirmYes" class="primary-btn" type="button" style="background:#dc3545;">Sim, sair sem salvar</button>
        <button id="finishConfirmNo" class="secondary-btn" type="button">Não, continuar</button>
      </div>
    </div>
  </div>

  <!-- Finalizar exame: confirmação + limpeza local -->
  <script>
    (function(){
      function getCurrentQuestion(){
        try {
          const el = document.getElementById('questionNumber');
          const idx = Number((el && el.textContent || '').trim());
          const zero = Number.isFinite(idx) ? idx - 1 : 0;
          const arr = Array.isArray(window.QUESTIONS) ? window.QUESTIONS : (function(){
            const sid = window.currentSessionId || null; if (!sid) return [];
            const raw = localStorage.getItem(`questions_${sid}`); if (!raw) return [];
            const a = JSON.parse(raw); return Array.isArray(a) ? a : [];
          })();
          return (zero >= 0 && zero < arr.length) ? arr[zero] : null;
        } catch(_) { return null; }
      }
      async function fetchHintForQuestion(id){
        try {
          if (!Number.isFinite(id)) return null;
          const headers = (() => {
            try {
              if (window.Auth && typeof window.Auth.getAuthHeaders === 'function') {
                return window.Auth.getAuthHeaders({ acceptJson: true });
              }
            } catch(_){ }
            const token = (localStorage.getItem('sessionToken') || '').trim();
            return token ? { 'X-Session-Token': token } : {};
          })();
          const r = await fetch(`/api/questions/view/${id}`, { headers });
          if (r && r.ok) { const q = await r.json(); return q && (q.dica || q.hint || null); }
        } catch(_){ }
        return null;
      }
      async function onHintClick(){
        try {
          const btn = document.getElementById('hintBtn'); if (btn) { btn.disabled = true; btn.setAttribute('aria-busy','true'); }
          const q = getCurrentQuestion();
          const hint = q && (q.dica || q.hint);
          const container = document.getElementById('hintContainer');
          let text = hint || null;
          if (!text && q && q.id != null) {
            text = await fetchHintForQuestion(q.id);
          }
          if (container) {
            if (text) {
              container.style.display = '';
              container.innerHTML = `<strong>Dica:</strong> ${text}`;
            } else {
              container.style.display = '';
              container.innerHTML = '<em>Nenhuma dica disponível para esta questão.</em>';
            }
          }
        } catch(_){ }
        finally {
          const btn = document.getElementById('hintBtn'); if (btn) { btn.disabled = false; btn.removeAttribute('aria-busy'); }
        }
      }
      function hideHint(){
        try {
          const container = document.getElementById('hintContainer');
          if (container) { container.style.display = 'none'; container.innerHTML = ''; }
        } catch(_){}
      }
      function clearExamData(){
        try {
          const sid = (window.currentSessionId || localStorage.getItem('currentSessionId') || localStorage.getItem('tempSessionId') || '').trim();
          if (sid) {
            const keys = [
              `progress_${sid}`,
              `answers_${sid}`,
              `questions_${sid}`,
              `highlights_${sid}`,
              `questoesMarcadas_${sid}`,
              `backBarrier_${sid}`,
              `allowContinueAfterCheckpoint_${sid}`,
              `pauseUntil_${sid}`,
              `pauseConsumed_${sid}_cp1`,
              `pauseConsumed_${sid}_cp2`,
              `FirstStop_${sid}`,
              `SecondStop_${sid}`
            ];
            keys.forEach(k => { try { localStorage.removeItem(k); } catch(_){ } });
          }
          ['examQuestionCount','examCountFromDefault','examFilters'].forEach(k=>{ try{ localStorage.removeItem(k);}catch(_){}});
        } catch(_){ }
        try { sessionStorage.clear(); } catch(_){ }
        try { if (window.caches && caches.keys) { caches.keys().then(names => names.forEach(n => caches.delete(n))).catch(()=>{}); } } catch(_){ }
        // TODO: Persistir no servidor
        try { if (typeof showToast === 'function') showToast('Exame finalizado. Dados locais limpos.'); } catch(_){ }
      }
      function openFinishConfirm(){
        // Calcula % de completude e injeta no modal unificado
        try {
          const totalQuestions = window.QUESTIONS ? window.QUESTIONS.length : 0;
          let percent = 0;
          if (totalQuestions > 0) {
            let answeredCount = 0;
            const answers = window.ANSWERS || {};
            for (let i = 0; i < totalQuestions; i++) {
              const q = window.QUESTIONS[i];
              const qKey = (q && (q.id !== undefined && q.id !== null)) ? `q_${q.id}` : `idx_${i}`;
              const a = answers[qKey];
              if (a && ((a.optionId != null && a.optionId !== '') || (Array.isArray(a.optionIds) && a.optionIds.length > 0))) {
                answeredCount++;
              }
            }
            percent = (answeredCount / totalQuestions) * 100;
          }
          const sp = document.getElementById('completionPercent');
          if (sp) sp.textContent = percent.toFixed(1) + '%';
        } catch(_){ }
        const m=document.getElementById('finishConfirmModal'); if(m){ m.style.display=''; m.setAttribute('aria-hidden','false'); }
      }
      function closeFinishConfirm(){ const m=document.getElementById('finishConfirmModal'); if(m){ m.style.display='none'; m.setAttribute('aria-hidden','true'); } }
      function attach(){
        const b = document.getElementById('finishExamBtn'); if (b) b.addEventListener('click', openFinishConfirm);
        const hb = document.getElementById('hintBtn'); if (hb) hb.addEventListener('click', onHintClick);
        const cb = document.getElementById('continueBtn'); if (cb) cb.addEventListener('click', hideHint, true);
        const bb = document.getElementById('backBtn'); if (bb) bb.addEventListener('click', hideHint, true);
  const yes = document.getElementById('finishConfirmYes'); if (yes) yes.addEventListener('click', ()=>{
    try { closeFinishConfirm(); } catch(_){ }
    // Fluxo simplificado: sair sem salvar (sem enviar ao backend)
    try { clearExamData(); } catch(_){ }
    try {
      const token = localStorage.getItem('sessionToken') || '';
      const hasIdentity = !!(localStorage.getItem('userId') || localStorage.getItem('nomeUsuario') || localStorage.getItem('nome'));
      const isGuest = token && token.endsWith('#');
      const isLogged = !!(token || hasIdentity) && !(isGuest && !hasIdentity);
      if (isLogged) { window.location.assign('/'); } else { try { sessionStorage.setItem('postLoginRedirect', window.location.href); } catch(_){ } window.location.assign('/login?redirect=' + encodeURIComponent(window.location.href)); }
    } catch(e){ try { sessionStorage.setItem('postLoginRedirect', window.location.href); } catch(_){ } window.location.assign('/login?redirect=' + encodeURIComponent(window.location.href)); }
  });
        const no = document.getElementById('finishConfirmNo'); if (no) no.addEventListener('click', closeFinishConfirm);
        window.addEventListener('keydown', (ev)=>{ if (ev.key === 'Escape') closeFinishConfirm(); });
      }
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach); else attach();
    })();
  </script>

  <div id="emailModal" class="modal" aria-hidden="true" style="display:none;">
    <div class="modal-content">
      <h2>Registro obrigatório</h2>
      <p>Por favor, informe seu nome e e-mail para registrar o aplicativo.</p>
      <input id="nameInput" type="text" placeholder="Seu nome completo" />
      <input id="emailInput" type="email" placeholder="seu@exemplo.com" />
  <input id="passwordInput" type="password" placeholder="Senha (mínimo 6 caracteres)" />
  <input id="verifyTokenInput" type="text" placeholder="Código de verificação (se recebeu por e-mail)" style="display:none;" />
      <div class="modal-actions">
        <button id="submitEmail">Registrar</button>
        <button id="toggleModeBtn" class="secondary-btn" type="button">Já tenho conta</button>
      </div>
      <p id="modalError" style="color:crimson;display:none;"></p>
    </div>
  </div>
</body>
</html>
