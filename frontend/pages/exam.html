<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulado — Questão</title>
  <!-- Prefer CSS minificado em dist quando disponível; mantém original como fallback -->
  <link rel="stylesheet" href="../dist/styles.css" />
  <link rel="stylesheet" href="../styles.css" />
</head>
<body>
  <header id="userHeader" style="display:none; padding:12px; background:#f4f4f4; border-bottom:1px solid #ddd;">
    <div style="max-width:900px;margin:0 auto;">Bem-vindo, <strong id="userNameHeader"></strong></div>
  </header>
  
  <div id="toast" class="toast" aria-live="polite" style="display:none"></div>

  <main class="exam-container" role="main" style="margin-top:8px;">
    <header class="exam-header" style="margin-bottom:8px; padding:4px 0;">
      <div class="header-left" aria-hidden="true"></div>

      <div class="header-center" id="centerHeader">
        <div class="knowledge-area" id="knowledgeArea" aria-live="polite">Exemplo</div>
        <div class="timer" id="timerBox" aria-live="polite" title="Tempo decorrido">
          <span id="timerDisplay">00:00</span>
        </div>
      </div>

      <div class="header-right controls">
        <div class="font-control">
          <button id="fontToggle" class="icon-btn" aria-expanded="false" aria-controls="fontSlider" title="Ajustar tamanho da fonte">Aa</button>
          <div id="fontSlider" class="font-slider" hidden>
            <label for="fontRange">Tamanho da fonte</label>
            <input id="fontRange" type="range" min="12" max="24" value="16" />
          </div>
        </div>
      </div>
    </header>

    

    <section class="question-panel" aria-labelledby="questionNumber">
      <div class="meta-row">
        <div id="qStatus" class="q-status">Questão <span id="questionNumber">1</span> / <span id="totalQuestions">1</span></div>
        <div class="feedback-buttons">
          <button id="bhighlight" class="icon-btn" type="button" title="Destacar/Remover destaque">
            <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M14 3.2L3.2 14 2 22l8-1.2L22.8 10 14 3.2z"></path>
              <path d="M2 22h10v2H2z"></path>
            </svg>
            Destacar questão
          </button>
          <button id="likeBtn" class="icon-like" aria-pressed="false" title="Gostei" aria-label="Gostei">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 21s-6.716-4.35-9.062-7.018C-0.413 10.983 2.973 6 7.5 6c1.84 0 3.515.756 4.5 2.01C13.985 6.756 15.66 6 17.5 6 22.027 6 25.413 10.983 21.062 13.982 18.716 16.65 12 21 12 21z" stroke="currentColor" stroke-width="1.2" fill="currentColor"/></svg>
          </button>
          <button id="dislikeBtn" class="icon-dislike" aria-pressed="false" title="Não gostei" aria-label="Não gostei">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 3s6.716 4.35 9.062 7.018C24.413 13.017 21.027 18 16.5 18c-1.84 0-3.515-.756-4.5-2.01C10.015 17.244 8.34 18 6.5 18 1.973 18 -1.413 13.017 2.938 10.018 5.284 7.35 12 3 12 3z" stroke="currentColor" stroke-width="1.2" fill="currentColor"/></svg>
          </button>
        </div>
      </div>

      <article class="question-content" id="questionContent">
        <p id="questionText" class="question-text">Carregando pergunta...</p>
        <div id="questionImageWrapper" style="display:none; margin:12px 0 16px; text-align:center;"></div>

        <form id="answersForm" class="answers-form" autocomplete="off" novalidate>
          <div id="answersContainer"></div>
        </form>

        <div class="actions-row" style="display:flex; align-items:center; gap:8px;">
          <button id="finishExamBtn" type="button" class="primary-btn" style="background:#FA8072;color:#fff; margin-right:auto;">Finalizar exame</button>
          <button id="backBtn" class="primary-btn" style="display:none;margin-right:8px;">Voltar</button>
          <button id="continueBtn" class="primary-btn">Continuar</button>
        </div>
      </article>
    </section>
  </main>
  <!-- define session vars required by exam pages -->
  <script>
    try {
      // Descobrir o blueprint do exame (se definido pelo setup ou pela API)
      let bp = null;
      try { const raw = localStorage.getItem('examBlueprint'); bp = raw ? JSON.parse(raw) : null; } catch(_) { bp = null; }

      // Defaults (PMP): 180 questões, 230 minutos
      const _tempoExame = (bp && Number(bp.duracaoMinutos)) ? Number(bp.duracaoMinutos) : 230; // em minutos
      const _FullExam = (bp && Number(bp.numeroQuestoes)) ? Number(bp.numeroQuestoes) : 180;

      sessionStorage.setItem('tempoExame', JSON.stringify(_tempoExame));
      sessionStorage.setItem('FullExam', JSON.stringify(_FullExam));
      // também expor como variáveis globais numéricas para uso imediato no script
      window.tempoExame = _tempoExame;
      window.FullExam = _FullExam;
      // Expor algumas flags do blueprint (usadas pelo script)
      window.ExamMultiplaSelecao = !!(bp && bp.multiplaSelecao);
      window.ExamCheckpoints = (bp && bp.pausas && Array.isArray(bp.pausas.checkpoints)) ? bp.pausas.checkpoints.slice() : [60,120];
    } catch (e) {
      console.warn('Falha ao definir variáveis de sessão:', e);
    }
  </script>
  <!-- Exibir imagem da questão (campo imagem_url / imagemUrl) abaixo do enunciado -->
  <script>
    (function(){
      function resolveQuestions(){
        try {
          if (Array.isArray(window.QUESTIONS)) return window.QUESTIONS;
          const sid = window.currentSessionId || null; if (!sid) return [];
          const raw = localStorage.getItem(`questions_${sid}`);
          if (!raw) return [];
          const arr = JSON.parse(raw); return Array.isArray(arr)? arr : [];
        } catch(_) { return []; }
      }
      function currentIndex(){
        try { const el = document.getElementById('questionNumber'); const n = Number((el&&el.textContent||'').trim()); return Number.isFinite(n)? n-1 : 0; } catch(_) { return 0; }
      }
      function buildSrc(str){
        if (!str) return null;
        const s = String(str).trim();
        if (!s) return null;
        if (/^data:image\//i.test(s)) return s;
        if (/^https?:\/\//i.test(s) || s.startsWith('/')) return s;
        if (/^data:/i.test(s)) return s;
        if (/^[A-Za-z0-9+/=]+$/.test(s) && s.length > 100) return 'data:image/png;base64,' + s;
        return s;
      }
      function renderImage(){
        try {
          const wrap = document.getElementById('questionImageWrapper'); if (!wrap) return;
          const qs = resolveQuestions(); const idx = currentIndex(); const q = (idx>=0 && idx < qs.length)? qs[idx] : null;
          const raw = q && (q.imagemUrl || q.imagem_url || q.imageUrl || q.image_url) || '';
          const src = buildSrc(raw);
          if (!src){ wrap.style.display='none'; wrap.innerHTML=''; return; }
          const img = document.createElement('img');
          img.src = src; img.alt='Imagem ilustrativa da questão'; img.style.maxWidth='680px'; img.style.width='100%'; img.style.height='auto'; img.style.border='1px solid #e2e8f0'; img.style.background='#fff'; img.style.borderRadius='6px'; img.style.boxShadow='0 1px 2px rgba(0,0,0,0.06)'; img.decoding='async'; img.loading='lazy';
          wrap.innerHTML=''; wrap.appendChild(img); wrap.style.display='block';
        } catch(_){}
      }
      document.addEventListener('exam:question-index-changed', renderImage);
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ()=>setTimeout(renderImage,120)); else setTimeout(renderImage,120);
    })();
  </script>

  <!-- registration/session script must run before exam script; prefer non-minified for safety with removed #status/#autosaveIndicator -->
  <script src="../script.js"></script>
  <!-- Intercept selection to bypass filters when count=180 and fallback ignoring exam_type if needed -->
  <script>
    (function(){
      try {
        const origFetch = window.fetch.bind(window);
        window.fetch = async function(input, init){
          try {
            const url = (typeof input === 'string') ? input : (input && input.url) || '';
            if (url && url.endsWith('/api/exams/select') && init && typeof init === 'object' && String(init.method||'').toUpperCase() === 'POST' && init.body) {
              let body = null; try { body = JSON.parse(init.body); } catch(_){ body = null; }
              const cnt = body && Number(body.count);
              const onlyCount = !!(body && body.onlyCount === true);
              // Injeta flag onlyNew se usuário premium e selecionado no setup
              try {
                const premium = localStorage.getItem('BloqueioAtivado') !== 'true';
                const onlyNewFlag = premium && localStorage.getItem('examOnlyNewQuestions') === 'true';
                if (onlyNewFlag && body && !body.onlyNew) {
                  body.onlyNew = true;
                  init.body = JSON.stringify(body);
                }
              } catch(e){}
              if (cnt === 180 && body) {
                delete body.areas; delete body.grupos; delete body.dominios;
                init.body = JSON.stringify(body);
              }
              const resp = await origFetch(input, init);
              if (resp && resp.status === 400 && cnt === 180) {
                let available = null;
                try { const t = await resp.clone().text(); const j = t ? JSON.parse(t) : null; if (j && typeof j.available === 'number') available = j.available; } catch(_){}
                if (available === 0) {
                  const headers = new Headers(init.headers || {});
                  headers.delete('X-Exam-Type');
                  return await origFetch(input, { method: 'POST', headers, body: JSON.stringify({ count: cnt, ignoreExamType: true, onlyCount }) });
                }
              }
              return resp;
            }
          } catch(_){ }
          return origFetch(input, init);
        };
      } catch(_){ }
    })();
  </script>
  <script src="../assets/build/script_exam.js" onerror="(function(){var s=document.createElement('script');s.src='../script_exam.js';document.body.appendChild(s);}())"></script>

  <!-- initialize global QtdQuestoes and timer behavior -->
  <script>
    (function(){
      try {
        // Session guard: require non-guest identity; else send to registration entrypoint
        try {
          const token = localStorage.getItem('sessionToken') || '';
          const hasIdentity = !!(localStorage.getItem('userId') || localStorage.getItem('nomeUsuario') || localStorage.getItem('nome'));
          if ((!token && !hasIdentity) || ((token && token.endsWith('#')) && !hasIdentity)) {
            try { sessionStorage.setItem('postLoginRedirect', window.location.href); } catch(_){ }
            window.location.assign('/login?redirect=' + encodeURIComponent(window.location.href));
            return;
          }
        } catch(e) {}

        // Read chosen question count from localStorage (set by examSetup)
        let q = null;
        try { q = localStorage.getItem('examQuestionCount'); } catch(e) { q = null; }
        const parsed = q ? Number(q) : null;
        // fallback to FullExam if not set
        const full = (typeof window.FullExam === 'number') ? window.FullExam : (sessionStorage.getItem('FullExam') ? JSON.parse(sessionStorage.getItem('FullExam')) : null);
        const qtd = (parsed && !isNaN(parsed)) ? parsed : 0;
        // Guard: se não houver quantidade definida pelo setup e não vier com startExam, encaminhar para a configuração
        const shouldStart = (sessionStorage.getItem('startExam') === 'true');
        if (!qtd && !shouldStart) {
          window.location.assign('/pages/examSetup.html');
          return;
        }
        const finalQtd = qtd || (full || 0);
        // expose as global numeric
        window.QtdQuestoes = Number(finalQtd);
        // update totalQuestions display on the exam page to reflect selection
        try {
          const totalEl = document.getElementById('totalQuestions');
          if (totalEl) totalEl.textContent = String(window.QtdQuestoes);
        } catch(e) { console.warn('update totalQuestions failed', e); }

        // Confirmação de exame completo (180) é tratada apenas na examSetup. Aqui iniciamos normalmente.

        // helper to format seconds to MM:SS or H:MM:SS if large
        function fmtSeconds(s){
          s = Math.max(0, Math.floor(s));
          if (s >= 3600) {
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60).toString().padStart(2,'0');
            const sec = (s % 60).toString().padStart(2,'0');
            return `${h}:${m}:${sec}`;
          }
          const m = Math.floor(s/60).toString().padStart(2,'0');
          const sec = (s % 60).toString().padStart(2,'0');
          return `${m}:${sec}`;
        }

        // compute total seconds proportional to quantidade selecionada:
        // 180 questões equivalem a 230 minutos => segundos = (QtdQuestoes / 180) * 230(min) * 60
        function computeSeconds() {
          const tempo = (typeof window.tempoExame === 'number') ? window.tempoExame : (sessionStorage.getItem('tempoExame') ? JSON.parse(sessionStorage.getItem('tempoExame')) : null); // minutos do exame completo
          const fullNum = (typeof window.FullExam === 'number') ? window.FullExam : (sessionStorage.getItem('FullExam') ? JSON.parse(sessionStorage.getItem('FullExam')) : null);
          const qtdNum = Number(window.QtdQuestoes) || 0;
          if (!tempo || !fullNum || !qtdNum) return 0;
          const totalMinutes = (qtdNum * tempo) / fullNum; // minutos proporcionais
          const seconds = totalMinutes * 60;
          return Math.max(0, Math.round(seconds));
        }

        // countdown state
        let _timerInterval = null;

        function startCountdown() {
          try {
            if (_timerInterval) return; // already running
            // allow resuming from persisted remaining seconds if available
            let remaining = computeSeconds();
            try {
              const progRaw = (window.currentSessionId && localStorage.getItem(`progress_${window.currentSessionId}`)) || null;
              if (progRaw) {
                const prog = JSON.parse(progRaw);
                if (prog && typeof prog === 'object' && prog.remainingSeconds !== undefined && prog.remainingSeconds !== null) {
                  remaining = Number(prog.remainingSeconds) || remaining;
                }
              }
            } catch(e) { /* ignore */ }
            const display = document.getElementById('timerDisplay');
            if (!display) return;
            display.textContent = fmtSeconds(remaining);
            _timerInterval = setInterval(() => {
              remaining -= 1;
              if (remaining <= 0) {
                display.textContent = fmtSeconds(0);
                clearInterval(_timerInterval);
                _timerInterval = null;
                // exam finished - you may want to auto-submit or notify
                try { alert('Tempo esgotado.'); } catch(e){}
                return;
              }
              display.textContent = fmtSeconds(remaining);
              // persist remaining seconds for resume
              try {
                if (window.currentSessionId) {
                  const key = `progress_${window.currentSessionId}`;
                  const cur = JSON.parse(localStorage.getItem(key) || '{}') || {};
                  cur.remainingSeconds = remaining;
                  localStorage.setItem(key, JSON.stringify(cur));
                  localStorage.setItem(`${key}_savedAt`, new Date().toISOString());
                }
              } catch(e) {}
            }, 1000);
          } catch (e) { console.warn('startCountdown error', e); }
        }

        // Auto-start if the user clicked "Iniciar Exame" (examSetup set sessionStorage.startExam = 'true')
        if (shouldStart) {
          // clear flag and begin
          try { sessionStorage.removeItem('startExam'); } catch(e){}
          startCountdown();
        }

        // Also expose start function globally so other UI can trigger it
        window.startExamCountdown = startCountdown;

      } catch (e) { console.warn('Init exam timer error', e); }
    })();
  </script>

  <!-- Registration modal (copied from index.html/modal) -->
  <!-- Modal de confirmação para finalizar exame (unificado) -->
  <div id="finishConfirmModal" class="modal" aria-hidden="true" style="display:none;">
    <div class="modal-content" style="max-width:600px; padding:20px; text-align:center;">
      <p style="margin:0 0 16px 0; font-size:16px; line-height:1.5;">
        <strong>Deseja mesmo encerrar o exame?</strong><br>
        Você respondeu <strong id="completionPercent">0%</strong> das questões deste exame.<br>
        Esta tentativa <strong>não será gravada</strong> na base de dados de exames realizados.<br><br>
        Deseja mesmo sair?
      </p>
      <div style="display:flex; gap:10px; justify-content:center; margin-top:14px;">
        <button id="finishConfirmYes" class="primary-btn" type="button" style="background:#dc3545;">Sim, sair sem salvar</button>
        <button id="finishConfirmNo" class="secondary-btn" type="button">Não, continuar</button>
      </div>
    </div>
  </div>

  <!-- Finalizar exame: confirmação + limpeza local -->
  <script>
    (function(){
      function clearExamData(){
        try {
          const sid = (window.currentSessionId || localStorage.getItem('currentSessionId') || localStorage.getItem('tempSessionId') || '').trim();
          if (sid) {
            const keys = [
              `progress_${sid}`,
              `answers_${sid}`,
              `questions_${sid}`,
              `highlights_${sid}`,
              `questoesMarcadas_${sid}`,
              `backBarrier_${sid}`,
              `allowContinueAfterCheckpoint_${sid}`,
              `pauseUntil_${sid}`,
              `pauseConsumed_${sid}_cp1`,
              `pauseConsumed_${sid}_cp2`,
              `FirstStop_${sid}`,
              `SecondStop_${sid}`
            ];
            keys.forEach(k => { try { localStorage.removeItem(k); } catch(_){ } });
          }
          ['examQuestionCount','examCountFromDefault','examFilters'].forEach(k=>{ try{ localStorage.removeItem(k);}catch(_){}});
        } catch(_){ }
        try { sessionStorage.clear(); } catch(_){ }
        try { if (window.caches && caches.keys) { caches.keys().then(names => names.forEach(n => caches.delete(n))).catch(()=>{}); } } catch(_){ }
        // TODO: Persistir no servidor
        try { if (typeof showToast === 'function') showToast('Exame finalizado. Dados locais limpos.'); } catch(_){ }
      }
      function openFinishConfirm(){
        // Calcula % de completude e injeta no modal unificado
        try {
          const totalQuestions = window.QUESTIONS ? window.QUESTIONS.length : 0;
          let percent = 0;
          if (totalQuestions > 0) {
            let answeredCount = 0;
            const answers = window.ANSWERS || {};
            for (let i = 0; i < totalQuestions; i++) {
              const q = window.QUESTIONS[i];
              const qKey = (q && (q.id !== undefined && q.id !== null)) ? `q_${q.id}` : `idx_${i}`;
              const a = answers[qKey];
              if (a && ((a.optionId != null && a.optionId !== '') || (Array.isArray(a.optionIds) && a.optionIds.length > 0))) {
                answeredCount++;
              }
            }
            percent = (answeredCount / totalQuestions) * 100;
          }
          const sp = document.getElementById('completionPercent');
          if (sp) sp.textContent = percent.toFixed(1) + '%';
        } catch(_){ }
        const m=document.getElementById('finishConfirmModal'); if(m){ m.style.display=''; m.setAttribute('aria-hidden','false'); }
      }
      function closeFinishConfirm(){ const m=document.getElementById('finishConfirmModal'); if(m){ m.style.display='none'; m.setAttribute('aria-hidden','true'); } }
      function attach(){
        const b = document.getElementById('finishExamBtn'); if (b) b.addEventListener('click', openFinishConfirm);
  const yes = document.getElementById('finishConfirmYes'); if (yes) yes.addEventListener('click', ()=>{
    try { closeFinishConfirm(); } catch(_){ }
    // Fluxo simplificado: sair sem salvar (sem enviar ao backend)
    try { clearExamData(); } catch(_){ }
    try {
      const token = localStorage.getItem('sessionToken') || '';
      const hasIdentity = !!(localStorage.getItem('userId') || localStorage.getItem('nomeUsuario') || localStorage.getItem('nome'));
      const isGuest = token && token.endsWith('#');
      const isLogged = !!(token || hasIdentity) && !(isGuest && !hasIdentity);
      if (isLogged) { window.location.assign('/'); } else { try { sessionStorage.setItem('postLoginRedirect', window.location.href); } catch(_){ } window.location.assign('/login?redirect=' + encodeURIComponent(window.location.href)); }
    } catch(e){ try { sessionStorage.setItem('postLoginRedirect', window.location.href); } catch(_){ } window.location.assign('/login?redirect=' + encodeURIComponent(window.location.href)); }
  });
        const no = document.getElementById('finishConfirmNo'); if (no) no.addEventListener('click', closeFinishConfirm);
        window.addEventListener('keydown', (ev)=>{ if (ev.key === 'Escape') closeFinishConfirm(); });
      }
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach); else attach();
    })();
  </script>

  <div id="emailModal" class="modal" aria-hidden="true" style="display:none;">
    <div class="modal-content">
      <h2>Registro obrigatório</h2>
      <p>Por favor, informe seu nome e e-mail para registrar o aplicativo.</p>
      <input id="nameInput" type="text" placeholder="Seu nome completo" />
      <input id="emailInput" type="email" placeholder="seu@exemplo.com" />
  <input id="passwordInput" type="password" placeholder="Senha (mínimo 6 caracteres)" />
  <input id="verifyTokenInput" type="text" placeholder="Código de verificação (se recebeu por e-mail)" style="display:none;" />
      <div class="modal-actions">
        <button id="submitEmail">Registrar</button>
        <button id="toggleModeBtn" class="secondary-btn" type="button">Já tenho conta</button>
      </div>
      <p id="modalError" style="color:crimson;display:none;"></p>
    </div>
  </div>
</body>
</html>
