<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Personalização de Simulado</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #f7f9fc;
      margin: 0;
      padding: 0;
    }

    .container {
      max-width: 800px;
      margin: 40px auto;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 30px;
    }

    header h1 {
      font-size: 1.6rem;
      margin-bottom: 10px;
      color: #222;
    }

    header p {
      color: #666;
      font-size: 0.9rem;
      margin-bottom: 15px;
    }

    .input-group {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .input-group input {
      width: 80px;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 1rem;
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 15px;
    }

    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      color: #555;
      transition: 0.3s;
    }

    .tab.active {
      color: #007bff;
      border-color: #007bff;
      font-weight: bold;
    }

    /* Checklist */
    .checklist {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-bottom: 25px;
    }

    .check-btn {
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s;
    }

    .check-btn:hover {
      background: #f0f8ff;
    }

    .check-btn.active {
      background: #007bff;
      color: #fff;
      border-color: #007bff;
    }

    /* Resumo */
    .resumo {
      border-top: 1px solid #eee;
      padding-top: 15px;
    }

    .resumo h3 {
      margin-bottom: 8px;
      font-size: 1.1rem;
      color: #333;
    }

    .resumo p {
      font-size: 0.9rem;
      color: #555;
    }
  </style>
  </head>
  <body>

  <div class="container">
    <!-- HEADER -->
    <header>
      <h1>Como você deseja estruturar seu simulado?</h1>
      <p id="limite-texto"></p>

      <div class="input-group">
        <label for="examType" style="min-width:180px;">Tipo de exame:</label>
        <select id="examType" style="flex:1;max-width:260px;padding:6px 8px;border:1px solid #ccc;border-radius:5px;font-size:1rem;"></select>
      </div>

      <div class="input-group">
        <label for="quantidade">Quantidade de questões:</label>
        <input type="number" id="quantidade" min="1" />
        <span id="limite-info"></span>
      </div>
    </header>

    <!-- TABS -->
    <div class="tabs">
      <div class="tab active" data-aba="dominios">Domínios</div>
      <div class="tab" data-aba="grupos">Grupo de Processos</div>
      <div class="tab" data-aba="areas">Área de Conhecimento</div>
    </div>

  <!-- CHECKLIST -->
  <div id="checklist" class="checklist"></div>

    <!-- RESUMO -->
    <div class="resumo">
      <h3>Resumo da Personalização</h3>
      <p>Quantidade de questões: <span id="resumo-qtd">-</span></p>
      <p>Focos selecionados: <span id="resumo-focos">Nenhum selecionado</span></p>
      <p id="errorMsg" style="display:none;margin-top:8px;color:#a23a2a;background:#fff4f2;border:1px solid #ffd2cc;padding:8px 10px;border-radius:8px;"></p>
      <div style="margin-top:12px; display:flex; gap:10px; align-items:center;">
        <button id="startExamBtn" style="background:#007bff;color:#fff;border:0;border-radius:8px;padding:10px 14px;cursor:pointer;">Iniciar simulado</button>
        <span id="startError" style="color:crimson; display:none;"></span>
      </div>
    </div>
  </div>

  <!-- Modal de confirmação para exame completo (180 questões) -->
  <div id="fullExamConfirmModal" class="modal" aria-hidden="true" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:1000;align-items:center;justify-content:center;">
    <div class="modal-content" style="background:#fff;border-radius:10px;max-width:620px;width:92%;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.2);">
      <h2 style="margin-top:0;margin-bottom:10px;">Você será direcionado para o exame completo. Deseja prosseguir?</h2>
      <h3 style="margin:10px 0 6px 0; font-size:1.05rem; color:#222;">Exame completo:</h3>
      <ul style="margin:8px 0 0 18px; padding:0; color:#333;">
        <li>Tempo total 230 minutos ou 3 horas e 49 minutos</li>
        <li>Você terá direito a 2 pausas de 10 minutos.</li>
        <li>A primeira pausa acontece ao concluir as questões de 1-60.</li>
        <li>A segunda pausa acontece ao concluir as questões de 61-120.</li>
        <li>Você não poderá voltar às questões anteriores assim que a pausa iniciar.</li>
        <li>5 questões do exame serão desconsideradas para efeitos de pré-teste</li>
      </ul>
      <div class="modal-actions" style="margin-top:16px;display:flex;gap:10px;justify-content:flex-end;">
        <button id="fullExamCancel" type="button" class="secondary-btn" style="background:#eef1f6;color:#334; border:1px solid #cfd6e4;border-radius:8px;padding:8px 12px;cursor:pointer;">Cancelar</button>
        <button id="fullExamProceed" type="button" class="primary-btn" style="background:#007bff;color:#fff;border:0;border-radius:8px;padding:8px 12px;cursor:pointer;">Prosseguir</button>
      </div>
    </div>
  </div>

  <script>
    // Resolve backend base if window.SIMULADOS_CONFIG is present (optional)
    const BACKEND_BASE = (window.SIMULADOS_CONFIG && window.SIMULADOS_CONFIG.BACKEND_BASE) || '';
    // Normalize session token: if guest ('#') but we have nomeUsuario/nome, fix it here (setup page doesn't load script.js)
    function getSessionToken(){
      try {
        let t = localStorage.getItem('sessionToken') || '';
        if (!t || t.endsWith('#')) {
          const alt = localStorage.getItem('nomeUsuario') || localStorage.getItem('nome') || '';
          if (alt) { localStorage.setItem('sessionToken', alt); return alt; }
        }
        return t;
      } catch(e){ return localStorage.getItem('sessionToken') || ''; }
    }
    // Ensure session variables exist; otherwise redirect to registration entrypoint (backend root)
    (function ensureSession(){
      try {
        const token = localStorage.getItem('sessionToken') || '';
        const hasIdentity = !!(localStorage.getItem('userId') || localStorage.getItem('nomeUsuario') || localStorage.getItem('nome'));
        const isGuest = token && token.endsWith('#');
        if ((!token && !hasIdentity) || (isGuest && !hasIdentity)) {
          window.location.assign('/login');
        }
      } catch(e) { /* ignore */ }
    })();

  const examTypeSelect = document.getElementById('examType');
  const quantidadeInput = document.getElementById('quantidade');
    const resumoQtd = document.getElementById('resumo-qtd');
    const resumoFocos = document.getElementById('resumo-focos');
    const checklistDiv = document.getElementById('checklist');
    const tabs = document.querySelectorAll('.tab');
    const startBtn = document.getElementById('startExamBtn');
    const startError = document.getElementById('startError');

  // Defaults; will be adjusted per exam type when loaded
  let currentExamType = (localStorage.getItem('examType') || 'pmp');
  // Determine limits from BloqueioAtivado in localStorage: 'true' => free user (limit 25), else premium (180)
    const bloqueado = (localStorage.getItem('BloqueioAtivado') === 'true');
  let limiteQuestoes = bloqueado ? 25 : 180;
    document.getElementById('limite-texto').textContent = bloqueado
      ? 'Usuário gratuito: limite de 25 questões.'
      : 'Usuário pagante: limite de 180 questões.';
    document.getElementById('limite-info').textContent = `(máx. ${limiteQuestoes})`;
  quantidadeInput.setAttribute('max', String(limiteQuestoes));
    quantidadeInput.setAttribute('min', '1');

    // State for meta lists and selections
    let abaAtual = 'dominios';
    let meta = { dominios: [], grupos: [], areas: [] };
    let selecionados = { dominios: [], grupos: [], areas: [] }; // arrays of ids

    // Try to rehydrate saved filters
    try {
      const raw = localStorage.getItem('examFilters');
      if (raw) {
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object') {
          if (Array.isArray(parsed.dominios)) selecionados.dominios = parsed.dominios.map(Number).filter(n=>!Number.isNaN(n));
          if (Array.isArray(parsed.grupos)) selecionados.grupos = parsed.grupos.map(Number).filter(n=>!Number.isNaN(n));
          if (Array.isArray(parsed.areas)) selecionados.areas = parsed.areas.map(Number).filter(n=>!Number.isNaN(n));
          if (parsed.activeTab && (parsed.activeTab === 'dominios' || parsed.activeTab === 'grupos' || parsed.activeTab === 'areas')) abaAtual = parsed.activeTab;
        }
      }
    } catch(e) {}

    function renderChecklist(items) {
      checklistDiv.innerHTML = '';
      const sel = selecionados[abaAtual] || [];
      items.forEach(item => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = item.descricao || item.label || String(item.id);
        btn.classList.add('check-btn');
        btn.setAttribute('data-id', String(item.id));
        if (sel.includes(Number(item.id))) btn.classList.add('active');
        btn.addEventListener('click', () => {
          const id = Number(btn.getAttribute('data-id'));
          const arr = selecionados[abaAtual];
          const idx = arr.indexOf(id);
          if (idx >= 0) { arr.splice(idx, 1); btn.classList.remove('active'); }
          else { arr.push(id); btn.classList.add('active'); }
          atualizarResumo();
          salvarSelecoes();
        });
        checklistDiv.appendChild(btn);
      });
    }

    function atualizarResumo() {
      resumoQtd.textContent = quantidadeInput.value || '-';
      const nomes = [];
      const pushFrom = (list, ids) => {
        const map = new Map(list.map(x => [Number(x.id), (x.descricao || x.label || String(x.id))]));
        ids.forEach(id => { if (map.has(Number(id))) nomes.push(map.get(Number(id))); });
      };
      pushFrom(meta.dominios, selecionados.dominios);
      pushFrom(meta.grupos, selecionados.grupos);
      pushFrom(meta.areas, selecionados.areas);
      resumoFocos.textContent = nomes.length ? nomes.join(', ') : 'Nenhum selecionado';
    }

    function salvarSelecoes() {
      try {
        const payload = { dominios: selecionados.dominios, grupos: selecionados.grupos, areas: selecionados.areas, activeTab: abaAtual };
        localStorage.setItem('examFilters', JSON.stringify(payload));
      } catch(e) {}
    }

    // Tab switching
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        abaAtual = tab.dataset.aba;
        salvarSelecoes();
        if (abaAtual === 'dominios') renderChecklist(meta.dominios);
        if (abaAtual === 'grupos') renderChecklist(meta.grupos);
        if (abaAtual === 'areas') renderChecklist(meta.areas);
      });
    });

    // Quantity input with clamping
    quantidadeInput.addEventListener('input', e => {
      let valor = parseInt(e.target.value, 10);
      if (Number.isNaN(valor)) { resumoQtd.textContent = '-'; return; }
      valor = Math.max(1, Math.min(limiteQuestoes, valor));
      e.target.value = String(valor);
      atualizarResumo();
    });

    function updateResumo(){ try { atualizarResumo(); } catch(e){} }

    function validateForm(){
      startError.style.display = 'none';
      const hasFocos = (selecionados.dominios.length + selecionados.grupos.length + selecionados.areas.length) > 0;
      const raw = quantidadeInput.value;
      const val = Number(raw);
      // Permitir iniciar com apenas filtros se houver focos selecionados
      if (!raw || Number.isNaN(val) || val < 1) {
        if (hasFocos) return true; // permitido sem quantidade
        startError.textContent = 'Informe a quantidade de questões ou selecione pelo menos um foco.';
        startError.style.display = 'inline';
        return false;
      }
      if (val > limiteQuestoes) {
        startError.textContent = `Quantidade acima do limite (${limiteQuestoes}).`;
        startError.style.display = 'inline';
        return false;
      }
      return true;
    }

    async function checkAvailability(count) {
      const base = (BACKEND_BASE || '').replace(/\/$/, '');
      const url = base + '/api/exams/select';
  const token = getSessionToken();
      const payload = { count: Number(count) || 0, onlyCount: true, examType: currentExamType };
      if (selecionados.areas.length) payload.areas = selecionados.areas;
      if (selecionados.grupos.length) payload.grupos = selecionados.grupos;
      if (selecionados.dominios.length) payload.dominios = selecionados.dominios;
      try {
        const resp = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Session-Token': token, 'X-Exam-Type': currentExamType }, body: JSON.stringify(payload) });
        const txt = await resp.text();
        let data; try { data = txt ? JSON.parse(txt) : null; } catch { data = null; }
        if (data && typeof data.available === 'number') return data.available;
        return null;
      } catch (e) { return null; }
    }

    function resolveEffectiveCount(){
      const raw = quantidadeInput.value;
      const val = Number(raw);
      const hasFocos = (selecionados.dominios.length + selecionados.grupos.length + selecionados.areas.length) > 0;
      if (raw && !Number.isNaN(val) && val >= 1) {
        return Math.max(1, Math.min(limiteQuestoes, val));
      }
      if (hasFocos) {
        // quando usuário não informou quantidade, usar padrão por perfil: 25 (bloqueado) ou 180 (premium)
        return bloqueado ? 25 : 180;
      }
      return null; // sem quantidade e sem focos -> inválido
    }

    function showFullExamConfirm(onProceed){
      const modal = document.getElementById('fullExamConfirmModal');
      const proceedBtn = document.getElementById('fullExamProceed');
      const cancelBtn = document.getElementById('fullExamCancel');
      if (!modal || !proceedBtn || !cancelBtn) return false;
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden','false');
      const close = ()=>{ modal.style.display = 'none'; modal.setAttribute('aria-hidden','true'); };
      cancelBtn.onclick = ()=>{ close(); };
      proceedBtn.onclick = ()=>{ try{ close(); }catch(e){}; if (typeof onProceed==='function') onProceed(); };
      return true;
    }

    // Start button: validate, preflight, persist, and redirect (com confirmação para 180)
    startBtn.addEventListener('click', async () => {
      startError.style.display = 'none';
      const errorBox = document.getElementById('errorMsg');
      if (errorBox) errorBox.style.display = 'none';
      if (!validateForm()) return;

      const effCount = resolveEffectiveCount();
      if (!effCount) return; // safety

      // Preflight: ask backend how many are available for current filters
      const available = await checkAvailability(effCount);
      if (typeof available === 'number' && available < effCount) {
        // Show friendly message and offer an Adjust button
        const btnId = 'ajustarQtdBtn';
        // Premium: não exibir mensagem — autoajustar e seguir, se houver disponíveis
        if (!bloqueado) {
          if (available > 0) {
            const suggested = available;
            quantidadeInput.value = String(suggested);
            updateResumo();
            // Se ajustou para 180, exigir confirmação antes de redirecionar
            if (suggested === 180) {
              showFullExamConfirm(() => {
                try {
                  localStorage.setItem('examQuestionCount', String(180));
                  localStorage.setItem('examCountFromDefault', quantidadeInput.value ? 'false' : 'true');
                } catch(e) {}
                salvarSelecoes();
                try { sessionStorage.setItem('startExam', 'true'); } catch(e) {}
                window.location.href = './examFull.html';
              });
              return;
            }
            // Caso contrário (premium com ajuste < 180), prosseguir normalmente
            try {
              localStorage.setItem('examQuestionCount', String(suggested));
              localStorage.setItem('examCountFromDefault', quantidadeInput.value ? 'false' : 'true');
            } catch(e) {}
            salvarSelecoes();
            try { sessionStorage.setItem('startExam', 'true'); } catch(e) {}
            window.location.href = './exam.html';
            return;
          } else {
            if (errorBox) {
              errorBox.innerHTML = `Nenhuma questão encontrada para os filtros selecionados.`;
              errorBox.style.display = '';
            }
            return;
          }
        }
        // Bloqueado: mostrar mensagem com sugestão (cap 25)
        if (errorBox) {
          const suggested = Math.min(available, 25);
          const msg = `Existem <strong>${available}</strong> questões que atendem aos filtros. No plano gratuito você pode iniciar com <strong>${suggested}</strong>.`;
          errorBox.innerHTML = msg + (suggested > 0 ? ` <button id="${btnId}" type="button" style="margin-left:6px;background:#eef3ff;color:#2b6cb0;border:1px solid #c6d3ff;border-radius:6px;padding:4px 8px;cursor:pointer">Ajustar para ${suggested}</button>` : '');
          errorBox.style.display = '';
          const btn = document.getElementById(btnId);
          if (btn) btn.onclick = () => {
            quantidadeInput.value = String(suggested);
            updateResumo();
            validateForm();
            errorBox.style.display = 'none';
          };
        }
        return;
      }
      // Persistência: se usuário não informou quantidade, salvar o count efetivo depois na exam.html
      // Entretanto, para a exam.html requisitar corretamente, salvamos agora o valor que será enviado —
      // exceto quando effCount === 180, onde pediremos confirmação antes de redirecionar
      const userProvided = !!quantidadeInput.value;
      if (effCount === 180) {
        // pedir confirmação antes de seguir para a página dedicada
        showFullExamConfirm(() => {
          try {
            localStorage.setItem('examQuestionCount', String(180));
            localStorage.setItem('examCountFromDefault', userProvided ? 'false' : 'true');
          } catch(e) {}
          salvarSelecoes();
          try { sessionStorage.setItem('startExam', 'true'); } catch(e) {}
          window.location.href = './examFull.html';
        });
        return;
      }
      try {
        localStorage.setItem('examQuestionCount', String(effCount));
        localStorage.setItem('examCountFromDefault', userProvided ? 'false' : 'true');
      } catch(e) {}
      salvarSelecoes();
      try { sessionStorage.setItem('startExam', 'true'); } catch(e) {}
      window.location.href = './exam.html';
    });

    async function fetchJson(url){
      const resp = await fetch(url, { headers: { 'X-Session-Token': getSessionToken() } });
      if (!resp.ok) throw new Error(`GET ${url} -> ${resp.status}`);
      return await resp.json();
    }

    async function loadMeta(){
      try {
        const base = (BACKEND_BASE || '').replace(/\/$/, '');
        const [doms, grps, ars] = await Promise.all([
          fetchJson(base + '/api/meta/dominios'),
          fetchJson(base + '/api/meta/grupos'),
          fetchJson(base + '/api/meta/areas')
        ]);
        meta.dominios = Array.isArray(doms) ? doms : [];
        meta.grupos = Array.isArray(grps) ? grps : [];
        meta.areas = Array.isArray(ars) ? ars : [];
      } catch (e) {
        console.warn('Falha ao carregar metadados, usando listas vazias.', e);
        meta.dominios = meta.dominios || [];
        meta.grupos = meta.grupos || [];
        meta.areas = meta.areas || [];
      }
      // restore quantity only if user saved previously; não definir valor automaticamente
      try {
        const saved = localStorage.getItem('examQuestionCount');
        if (saved) {
          quantidadeInput.value = String(Math.max(1, Math.min(limiteQuestoes, Number(saved))));
        }
      } catch(e) {}
      // activate tab per saved state
      tabs.forEach(t => t.classList.remove('active'));
      const tabEl = document.querySelector(`.tab[data-aba="${abaAtual}"]`) || document.querySelector('.tab[data-aba="dominios"]');
      if (tabEl) tabEl.classList.add('active');
      // render current tab
      if (abaAtual === 'dominios') renderChecklist(meta.dominios);
      if (abaAtual === 'grupos') renderChecklist(meta.grupos);
      if (abaAtual === 'areas') renderChecklist(meta.areas);
      atualizarResumo();
    }

    async function loadExamTypes(){
      const base = (BACKEND_BASE || '').replace(/\/$/, '');
      try {
        const resp = await fetch(base + '/api/exams/types');
        const types = await resp.json();
        examTypeSelect.innerHTML = '';
        (types || []).forEach(t => {
          const opt = document.createElement('option');
          opt.value = t.id;
          opt.textContent = `${t.nome || t.id} (${t.numeroQuestoes} questões)`;
          examTypeSelect.appendChild(opt);
        });
        // restore selection
        if (currentExamType) examTypeSelect.value = currentExamType;
        // update constraints based on type
        const sel = (types || []).find(x => x.id === currentExamType) || (types || [])[0];
        if (sel) {
          // Ajuste limite máximo proporcional ao tipo; manter cap de 25 para bloqueado
          const maxByType = Number(sel.numeroQuestoes) || 180;
          limiteQuestoes = bloqueado ? Math.min(25, maxByType) : maxByType;
          document.getElementById('limite-info').textContent = `(máx. ${limiteQuestoes})`;
          quantidadeInput.setAttribute('max', String(limiteQuestoes));
          try { localStorage.setItem('examBlueprint', JSON.stringify(sel)); } catch(e){}
        }
      } catch (e) {
        // fallback: ensure selection exists
        const opt = document.createElement('option');
        opt.value = currentExamType || 'pmp';
        opt.textContent = 'PMP (180 questões)';
        examTypeSelect.appendChild(opt);
      }
    }

    examTypeSelect.addEventListener('change', () => {
      currentExamType = examTypeSelect.value || 'pmp';
      try { localStorage.setItem('examType', currentExamType); } catch(e){}
      // Reset quantity clamp on change
      const maxByType = (()=>{ try { const bp = JSON.parse(localStorage.getItem('examBlueprint')||'null'); return (bp && bp.numeroQuestoes) || 180; } catch(e){ return 180; } })();
      limiteQuestoes = bloqueado ? Math.min(25, maxByType) : maxByType;
      document.getElementById('limite-info').textContent = `(máx. ${limiteQuestoes})`;
      quantidadeInput.setAttribute('max', String(limiteQuestoes));
      atualizarResumo();
    });

    // Kick off
    loadExamTypes();
    loadMeta();
  </script>
  </body>
  </html>
