<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <!-- Controlled Logging System (must load before other scripts) -->
  <script src="/utils/logger.js"></script>
  <!-- CSRF Protection (adds X-CSRF-Token for /api requests) -->
  <script src="/utils/csrf.js"></script>
  <script src="/utils/auth.js"></script>
  <!-- Support chat widget (served via backend /chat proxy) -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Personalização de Simulado</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      font-size: 13px;
      background: #f7f9fc;
      margin: 0;
      padding: 0;
    }

    .container {
      max-width: 760px;
      margin: 16px auto;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 16px;
    }

    /*
      When this page is loaded inside index.html (desktop layout), some global rules can
      force white text (e.g. selectors using `* { color: #fff !important; }`), making
      content inside the white container unreadable. Keep this page readable by
      enforcing intended colors inside the setup container.
    */
    .container, .container * { color: #222 !important; }
    header p { color: #666 !important; }
    .tab { color: #555 !important; }
    .tab.active { color: #007bff !important; }
    .check-btn.active { color: #fff !important; }
    #startExamBtn { color: #fff !important; }
    #errorMsg { color: #a23a2a !important; }

    header h1 {
      font-size: 1.12rem;
      margin-bottom: 6px;
      color: #222;
    }

    header p {
      color: #666;
      font-size: 0.8rem;
      margin-bottom: 10px;
    }

    .input-group {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 10px;
    }

    .input-group input {
      width: 64px;
      padding: 4px 6px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 0.9rem;
      min-height: 30px;
    }

    /* Presets de quantidade */
    .qtd-presets {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .qtd-opt {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border: 1px solid #d6d9e0;
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      user-select: none;
      font-size: 0.9rem;
    }
    .qtd-opt input[type="checkbox"] {
      width: 16px;
      height: 16px;
      min-width: 16px;
      min-height: 16px;
      cursor: pointer;
    }
    .qtd-opt.disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .qtd-opt .premium-badge {
      font-size: 0.72rem;
      color: #8a2be2;
      border: 1px solid #e7d7ff;
      background: #faf5ff;
      padding: 1px 6px;
      border-radius: 999px;
    }

    /* Caixa "Somente questões inéditas" menor e discreta */
    #onlynew-wrapper input[type="checkbox"] {
      width: 16px;
      height: 16px;
      min-width: 16px;
      min-height: 16px;
      margin-right: 4px;
      transform: scale(0.85);
      transform-origin: left center;
      cursor: pointer;
    }

    @media (min-width: 640px){
      #onlynew-wrapper input[type="checkbox"] { transform: scale(0.8); }
    }

    /* Ensure select follows compact sizing even if inline styles exist */
    #examType {
      font-size: 0.9rem !important;
      padding: 4px 6px !important;
      min-height: 32px;
    }
    /* Reduce inline-labeled min-width of the examType label */
    label[for="examType"] { min-width: 140px !important; font-size: 0.9rem; }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 8px;
    }

    .tab {
      padding: 6px 10px;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      color: #555;
      transition: 0.3s;
    }

    .tab.active {
      color: #007bff;
      border-color: #007bff;
      font-weight: bold;
    }

    /* Checklist */
    .checklist {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px;
      margin-bottom: 12px;
    }

    .check-btn {
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.95em;
    }

    .check-btn:hover {
      background: #f0f8ff;
    }

    .check-btn.active {
      background: #007bff;
      color: #fff;
      border-color: #007bff;
    }

    /* Resumo */
    .resumo {
      border-top: 1px solid #eee;
      padding-top: 10px;
    }

    .resumo h3 {
      margin-bottom: 6px;
      font-size: 0.95rem;
      color: #333;
    }

    .resumo p {
      font-size: 0.8rem;
      color: #555;
    }

    /* Top-left menu button */
    .menu-toggle {
      position: fixed;
      top: 8px;
      left: 8px;
      z-index: 1100;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      border: 1px solid #d6d9e0;
      background: #fff;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    body[data-layout='desktop'] .menu-toggle { display: none !important; }
    body[data-layout='desktop'] .menu-panel { display: none !important; }
    .menu-toggle:hover { background: #f7f9fc; }
    .ui-menu-icon-set-hamburger-mobile {
      display:inline-block;
      width: 18px;
      height: 2px;
      background: #333;
      border-radius: 2px;
      box-shadow: 0 6px 0 0 #333, 0 -6px 0 0 #333;
    }
    /* Simple dropdown panel */
    .menu-panel {
      position: fixed;
      top: 44px;
      left: 8px;
      z-index: 1099;
      background: #fff;
      border: 1px solid #d6d9e0;
      border-radius: 10px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.12);
      min-width: 180px;
      padding: 6px;
      display: none;
    }
    .menu-panel.open { display: block; }
    .menu-panel a {
      display: block;
      padding: 6px 8px;
      color: #222;
      text-decoration: none;
      border-radius: 6px;
    }
    .menu-panel a:hover { background: #f4f7fb; }

    /* Primary actions compact but tappable */
    #startExamBtn,
    .modal .primary-btn,
    .modal .secondary-btn,
    .menu-panel a,
    .check-btn {
      min-height: 32px;
    }

    /* Ultra-compact mode on larger screens, and optional body.compact to force it anywhere */
    @media (min-width: 640px){
      body { font-size: 12px; }
      .container { max-width: 720px; padding: 14px; margin: 12px auto; }
      header h1 { font-size: 1.02rem; margin-bottom: 4px; }
      header p { font-size: 0.78rem; margin-bottom: 8px; }
      .input-group { gap: 6px; margin-bottom: 8px; }
      .input-group input { width: 60px; min-height: 28px; padding: 3px 6px; font-size: 0.88rem; }
      #examType { min-height: 30px; padding: 4px 6px !important; font-size: 0.88rem !important; }
      .tabs { margin-bottom: 8px; }
      .tab { padding: 4px 8px; }
      .checklist { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px; margin-bottom: 10px; }
      .check-btn { padding: 5px; font-size: 0.92em; border-radius: 5px; }
      .resumo { padding-top: 8px; }
      .resumo h3 { font-size: 0.92rem; }
      .resumo p { font-size: 0.78rem; }
      #startExamBtn { padding: 5px 8px; min-height: 28px; }
      .menu-toggle { width: 28px; height: 28px; top: 6px; left: 6px; }
      .ui-menu-icon-set-hamburger-mobile { width: 16px; }
      .menu-panel { top: 40px; min-width: 160px; }
      .menu-panel a { padding: 5px 8px; }
      .modal .primary-btn, .modal .secondary-btn { min-height: 28px; padding: 5px 8px; }
      .modal .modal-content { max-width: 520px; padding: 14px !important; }
    }

    body.compact .container { max-width: 720px; padding: 14px; margin: 12px auto; }
    body.compact header h1 { font-size: 1.02rem; margin-bottom: 4px; }
    body.compact header p { font-size: 0.78rem; margin-bottom: 8px; }
    body.compact .input-group { gap: 6px; margin-bottom: 8px; }
    body.compact .input-group input { width: 60px; min-height: 28px; padding: 3px 6px; font-size: 0.88rem; }
    body.compact #examType { min-height: 30px; padding: 4px 6px !important; font-size: 0.88rem !important; }
    body.compact .tabs { margin-bottom: 8px; }
    body.compact .tab { padding: 4px 8px; }
    body.compact .checklist { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px; margin-bottom: 10px; }
    body.compact .check-btn { padding: 5px; font-size: 0.92em; border-radius: 5px; }
    body.compact .resumo { padding-top: 8px; }
    body.compact .resumo h3 { font-size: 0.92rem; }
    body.compact .resumo p { font-size: 0.78rem; }
    body.compact #startExamBtn { padding: 5px 8px; min-height: 28px; }
    body.compact .menu-toggle { width: 28px; height: 28px; top: 6px; left: 6px; }
    body.compact .ui-menu-icon-set-hamburger-mobile { width: 16px; }
    body.compact .menu-panel { top: 40px; min-width: 160px; }
    body.compact .menu-panel a { padding: 5px 8px; }
    body.compact .modal .primary-btn, body.compact .modal .secondary-btn { min-height: 28px; padding: 5px 8px; }
    body.compact .modal .modal-content { max-width: 520px; padding: 14px !important; }
  </style>
  <script src="/utils/logout.js"></script>
  </head>
  <body>

  <!-- Top-left menu button and dropdown -->
  <button id="menuToggle" class="menu-toggle" type="button" aria-haspopup="true" aria-expanded="false" aria-label="Abrir menu">
    <span class="ui-menu-icon-set-hamburger-mobile" aria-hidden="true"></span>
  </button>
  <nav id="pageMenu" class="menu-panel" aria-hidden="true" aria-label="Menu rápido">
    <a href="/" rel="noopener">Início (Menu)</a>
    <a href="/pages/examSetup.html?examType=pmp" rel="noopener">Simulador PMP</a>
    <a href="/pages/examSetup.html?examType=cpm" rel="noopener">Simulador CPM</a>
    <a href="/pages/results.html" rel="noopener">Resultados</a>
    <a href="#" class="page-logout">Sair</a>
  </nav>

  <div class="container">
    <!-- HEADER -->
    <header>
      <h1>Como você deseja estruturar seu simulado?</h1>
      <p id="limite-texto"></p>

      <div class="input-group">
        <label for="examType" style="min-width:180px;">Tipo de exame:</label>
        <select id="examType" style="flex:1;max-width:260px;padding:6px 8px;border:1px solid #ccc;border-radius:5px;font-size:1rem;"></select>
      </div>

      <div class="input-group">
        <label style="min-width:180px;">Quantidade de questões:</label>
        <div class="qtd-presets" id="qtdPresets" aria-label="Escolha a quantidade de questões">
          <label class="qtd-opt" data-qtd-label>
            <input type="checkbox" data-qtd="25" />
            <span>25</span>
          </label>
          <label class="qtd-opt" data-qtd-label>
            <input type="checkbox" data-qtd="30" />
            <span>30</span>
          </label>
          <label class="qtd-opt" data-qtd-label>
            <input type="checkbox" data-qtd="50" data-premium-only="true" />
            <span>50</span>
            <span class="premium-badge" style="display:none;">só para premium</span>
          </label>
          <label class="qtd-opt" data-qtd-label>
            <input type="checkbox" data-qtd="75" data-premium-only="true" />
            <span>75</span>
            <span class="premium-badge" style="display:none;">só para premium</span>
          </label>
          <label class="qtd-opt" data-qtd-label>
            <input type="checkbox" data-qtd="90" data-premium-only="true" />
            <span>90</span>
            <span class="premium-badge" style="display:none;">só para premium</span>
          </label>
        </div>
        <span id="limite-info" style="margin-left:6px;"></span>
      </div>
      <div class="input-group" id="onlynew-wrapper">
        <label for="onlyNew" style="min-width:180px;">Somente questões inéditas:</label>
        <input type="checkbox" id="onlyNew" />
        <span id="onlynew-info" style="font-size:0.72rem;color:#666;"></span>
      </div>
    </header>

    <!-- TABS -->
    <div class="tabs">
      <div class="tab active" data-aba="dominios">Domínios</div>
      <div class="tab" data-aba="grupos">Grupo de Processos</div>
      <!-- Área de Conhecimento desativada -->
      <div class="tab" data-aba="abordagem">Abordagem</div>
    </div>

  <!-- CHECKLIST (renderiza itens de todas as abas, incluindo Abordagem) -->
  <div id="checklist" class="checklist"></div>

    <!-- RESUMO -->
    <div class="resumo">
      <h3>Resumo da Personalização</h3>
      <p>
        <strong>Seu filtro:</strong>
        <span id="resumo-focos" style="font-weight:600;color:#0b5ed7;">Nenhum selecionado</span>
        <span id="resumo-available-wrap">
          <span style="color:#444;"> resulta em </span>
          <span id="resumo-qtd">-</span> questões disponíveis
        </span>
        <span style="color:#444;"> — você vai iniciar com </span>
        <span id="resumo-qtd-escolhida" style="font-weight:700;color:#198754;">-</span> questões
      </p>
      <p id="ineditasInfo" style="display:none;">Inéditas disponíveis: <span id="resumo-ineditas">-</span></p>
      <p id="errorMsg" style="display:none;margin-top:8px;color:#a23a2a;background:#fff4f2;border:1px solid #ffd2cc;padding:8px 10px;border-radius:8px;"></p>
      <div style="margin-top:12px; display:flex; gap:10px; align-items:center;">
  <button id="startExamBtn" style="background:#007bff;color:#fff;border:0;border-radius:6px;padding:6px 10px;min-height:32px;cursor:pointer;">Iniciar simulado</button>
        <span id="startError" style="color:crimson; display:none;"></span>
      </div>
    </div>
  </div>

  <!-- Modal de confirmação para exame completo (180 questões) - carregado dinamicamente do componente -->
  <script>
    (function(){
      // Attempt to load reusable component from ../components/fullExamConfirm.html and append to body
      async function loadFullExamConfirm(){
        try {
          const resp = await fetch('../components/fullExamConfirm.html');
          if (!resp.ok) return;
          const html = await resp.text();
          const wrapper = document.createElement('div');
          wrapper.innerHTML = html;
          const el = wrapper.firstElementChild;
          if (el) document.body.appendChild(el);
        } catch (e) {
          logger.warn('Não foi possível carregar o componente fullExamConfirm:', e);
        }
      }
      // load asynchronously but early
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadFullExamConfirm);
      } else { loadFullExamConfirm(); }
    })();
  </script>

  

  <script>
    // Resolve backend base if window.SIMULADOS_CONFIG is present (optional)
    const BACKEND_BASE = (window.SIMULADOS_CONFIG && window.SIMULADOS_CONFIG.BACKEND_BASE) || '';
    // Normalize session token: if guest ('#') but we have nomeUsuario/nome, fix it here (setup page doesn't load script.js)
    function getSessionToken(){
      try {
        let t = localStorage.getItem('sessionToken') || '';
        if (!t || t.endsWith('#')) {
          const alt = localStorage.getItem('nomeUsuario') || localStorage.getItem('nome') || '';
          if (alt) { localStorage.setItem('sessionToken', alt); return alt; }
        }
        return t;
      } catch(e){ return localStorage.getItem('sessionToken') || ''; }
    }
    // Ensure session variables exist; otherwise redirect to registration entrypoint (backend root)
    (function ensureSession(){
      try {
        const token = localStorage.getItem('sessionToken') || '';
        const hasIdentity = !!(localStorage.getItem('userId') || localStorage.getItem('nomeUsuario') || localStorage.getItem('nome'));
        const isGuest = token && token.endsWith('#');
        if ((!token && !hasIdentity) || (isGuest && !hasIdentity)) {
          try { sessionStorage.setItem('postLoginRedirect', window.location.href); } catch(_){ }
          window.location.assign('/login?redirect=' + encodeURIComponent(window.location.href));
        }
      } catch(e) { /* ignore */ }
    })();

  // Lightweight menu toggle and logout for this page
  (function initTopMenu(){
    // Skip in desktop mode
    if (document.body.getAttribute('data-layout') === 'desktop') return;
    
    const btn = document.getElementById('menuToggle');
    const panel = document.getElementById('pageMenu');
    if (!btn || !panel) return;
    const close = ()=>{ panel.classList.remove('open'); panel.setAttribute('aria-hidden','true'); btn.setAttribute('aria-expanded','false'); };
    const open = ()=>{ panel.classList.add('open'); panel.setAttribute('aria-hidden','false'); btn.setAttribute('aria-expanded','true'); };
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if (panel.classList.contains('open')) close(); else open();
    });
    document.addEventListener('click', (e)=>{
      if (!panel.contains(e.target) && e.target !== btn) close();
    });
    const logout = panel.querySelector('.page-logout');
    if (logout) logout.addEventListener('click', (e)=>{
      e.preventDefault();
      if (window.performLogout) {
        window.performLogout({ confirm: false, showNotification: false });
      } else {
        try { localStorage.clear(); sessionStorage.clear(); document.cookie = 'sessionToken=; Max-Age=0; Path=/'; } catch(_){}
        window.location.assign('/login');
      }
    });
  })();

  const examTypeSelect = document.getElementById('examType');
  const qtdPresetsDiv = document.getElementById('qtdPresets');
  const qtdPresetInputs = Array.from(document.querySelectorAll('#qtdPresets input[type="checkbox"][data-qtd]'));
  const onlyNewInput = document.getElementById('onlyNew');
  const onlyNewInfo = document.getElementById('onlynew-info');
    const resumoQtd = document.getElementById('resumo-qtd');
    const resumoQtdEscolhida = document.getElementById('resumo-qtd-escolhida');
    const resumoAvailableWrap = document.getElementById('resumo-available-wrap');
    const resumoFocos = document.getElementById('resumo-focos');
    const resumoIneditas = document.getElementById('resumo-ineditas');
    const ineditasInfo = document.getElementById('ineditasInfo');
    const checklistDiv = document.getElementById('checklist');
    const tabs = document.querySelectorAll('.tab');
    const startBtn = document.getElementById('startExamBtn');
    const startError = document.getElementById('startError');

  // Defaults; will be adjusted per exam type when loaded
  let currentExamType = (localStorage.getItem('examType') || 'pmp');
  // Allow URL to override stored exam type (e.g., ?examType=pmp)
  try {
    const qp = new URLSearchParams(window.location.search).get('examType');
    if (qp) currentExamType = qp;
  } catch(_) {}
  // Determine limits from server config (.env) and user plan
    const bloqueado = (localStorage.getItem('BloqueioAtivado') === 'true');
  let FULL_Q = 180;
  let FREE_LIMIT = 25;
  let onlyNewPremiumOnly = true;
  let allowOnlyNew = !bloqueado;

  function getFreeUiLimit(){
    // Requisito: usuários gratuitos podem escolher 25 ou 30.
    return Math.max(Number(FREE_LIMIT) || 0, 30);
  }

  function applyOnlyNewGate(){
    try {
      if (!onlyNewInput) return;
      if (!allowOnlyNew) {
        onlyNewInput.checked = false;
        onlyNewInput.disabled = true;
        if (onlyNewInfo) onlyNewInfo.textContent = 'Recurso Premium';
        if (ineditasInfo) ineditasInfo.style.display = 'none';
      } else {
        onlyNewInput.disabled = false;
        if (onlyNewInfo && !(onlyNewInput && onlyNewInput.checked)) {
          onlyNewInfo.textContent = 'Usar apenas questões nunca respondidas.';
        }
        if (ineditasInfo) ineditasInfo.style.display = '';
      }
    } catch(e){}
  }
  let limiteQuestoes = bloqueado ? getFreeUiLimit() : FULL_Q;

  function getSelectedPresetCount(){
    try {
      const checked = qtdPresetInputs.find(i => i && i.checked);
      if (!checked) return null;
      const n = Number(checked.getAttribute('data-qtd'));
      return Number.isFinite(n) ? n : null;
    } catch(_){ return null; }
  }

  function setSelectedPresetCount(n){
    try {
      const target = Number(n);
      qtdPresetInputs.forEach(inp => {
        const v = Number(inp.getAttribute('data-qtd'));
        inp.checked = (Number.isFinite(v) && v === target);
      });
    } catch(_){ }
  }

  function clearPresetSelection(){
    try { qtdPresetInputs.forEach(inp => { inp.checked = false; }); } catch(_){ }
  }

  function ensureSinglePresetSelection(changed){
    try {
      if (!changed || !changed.checked) return;
      qtdPresetInputs.forEach(inp => { if (inp !== changed) inp.checked = false; });
    } catch(_){ }
  }

  function applyQuestionCountGate(){
    // Usuário gratuito: só permitir 25 e 30
    try {
      qtdPresetInputs.forEach(inp => {
        const qtd = Number(inp.getAttribute('data-qtd'));
        const premiumOnly = inp.getAttribute('data-premium-only') === 'true';
        const label = inp.closest('[data-qtd-label]');
        const badge = label ? label.querySelector('.premium-badge') : null;

        const shouldDisable = bloqueado && premiumOnly;
        inp.disabled = !!shouldDisable;
        if (shouldDisable && inp.checked) inp.checked = false;

        if (label) {
          label.classList.toggle('disabled', !!shouldDisable);
          if (shouldDisable) {
            label.title = 'só para premium';
          } else {
            label.title = '';
          }
        }
        if (badge) {
          badge.style.display = shouldDisable ? '' : 'none';
        }
      });
    } catch(_){ }

    // Default selection
    try {
      const selected = getSelectedPresetCount();
      if (!selected) {
        // free: 25; premium: deixar sem seleção para permitir "exame completo" por padrão
        if (bloqueado) setSelectedPresetCount(25);
      }
    } catch(_){ }
  }
  (async function initLimits(){
    try {
      const base = (BACKEND_BASE || '').replace(/\/$/, '');
      const cfg = await fetch(base + '/api/meta/config').then(r => r.ok ? r.json() : null).catch(()=>null);
      if (cfg) {
        if (typeof cfg.fullExamQuestionCount === 'number') FULL_Q = cfg.fullExamQuestionCount;
        if (typeof cfg.freeExamQuestionLimit === 'number') FREE_LIMIT = cfg.freeExamQuestionLimit;
      }

      const up = await fetch(base + '/api/meta/user-params').then(r => r.ok ? r.json() : null).catch(()=>null);
      if (up && up.params && up.params.premiumOnly) {
        onlyNewPremiumOnly = !(up.params.premiumOnly.onlyNewQuestions === false);
      }
      allowOnlyNew = (!bloqueado) || (!onlyNewPremiumOnly);
    } catch(_){}
    // recompute with config
    limiteQuestoes = bloqueado ? getFreeUiLimit() : FULL_Q;
    document.getElementById('limite-texto').textContent = bloqueado
      ? `Usuário gratuito: limite de ${getFreeUiLimit()} questões.`
      : `Usuário pagante: limite de ${limiteQuestoes} questões.`;
    document.getElementById('limite-info').textContent = `(máx. ${limiteQuestoes})`;

    applyQuestionCountGate();

    applyOnlyNewGate();
  })();
  applyQuestionCountGate();
    // Inicializa campo Somente questões inéditas
    applyOnlyNewGate();

    function updateOnlyNewInfoText(opts = {}){
      if (!allowOnlyNew || !onlyNewInfo) return;
      const checked = !!(onlyNewInput && onlyNewInput.checked);
      if (!checked) {
        onlyNewInfo.textContent = 'Usar apenas questões nunca respondidas.';
        return;
      }
      if (opts && opts.pending) {
        onlyNewInfo.textContent = 'Inéditas disponíveis: ...';
        return;
      }
      const n = opts ? opts.count : null;
      if (typeof n === 'number' && Number.isFinite(n)) {
        onlyNewInfo.textContent = `Inéditas disponíveis: ${n}`;
      } else {
        onlyNewInfo.textContent = 'Inéditas disponíveis: -';
      }
    }

    // State for meta lists and selections
    // Área de Conhecimento desativada (aba + endpoints + filtros)
    let abaAtual = 'dominios';
    let meta = { dominios: [], grupos: [], categorias: [] };
    let selecionados = { dominios: [], grupos: [], categorias: [] }; // arrays of ids (categorias: single id stored as array)
  // Placeholder para função de atualização de contagem (será definida mais abaixo)
  // Isso evita ReferenceError em chamadas iniciais durante o carregamento.
  let scheduleAtualizarDisponiveis = function(){};

    // Debounce utilitário (escopo global do script)
    function debounce(fn, delay){
      let t = null;
      return function(...args){ clearTimeout(t); t = setTimeout(() => fn.apply(this, args), delay); };
    }

    function getExamAuthHeaders({ acceptJson = false, contentType = null, extra = null } = {}){
      try {
        if (window.Auth && typeof window.Auth.getAuthHeaders === 'function') {
          return window.Auth.getAuthHeaders({ acceptJson, contentType, extra });
        }
      } catch(_){ }
      const token = (typeof getSessionToken === 'function') ? getSessionToken() : (localStorage.getItem('sessionToken') || '');
      const h = {};
      if (acceptJson) h['Accept'] = 'application/json';
      if (contentType) h['Content-Type'] = contentType;
      if (token) h['X-Session-Token'] = token;
      try {
        const jwtTok = (localStorage.getItem('jwt')||'').trim();
        const jwtType = (localStorage.getItem('jwt_type')||'Bearer').trim() || 'Bearer';
        if (jwtTok) h['Authorization'] = `${jwtType} ${jwtTok}`;
      } catch(_){ }
      if (extra && typeof extra === 'object') {
        Object.keys(extra).forEach(k => {
          const v = extra[k];
          if (v != null && String(v).trim() !== '') h[k] = v;
        });
      }
      return h;
    }

    // Contagem sempre respeitando filtros (sem bypass por FULL_Q) e com retorno de SQL de depuração
    async function countForCurrentFilters() {
      const base = (BACKEND_BASE || '').replace(/\/$/, '');
      const url = base + '/api/exams/select';
      const token = getSessionToken();
      // Usar count=1 para não acionar bypassFilters de FULL_Q em outras rotas auxiliares
      const payload = { count: 1, onlyCount: true, examType: currentExamType };
      if (selecionados.grupos.length) payload.grupos = selecionados.grupos;
      if (selecionados.dominios.length) payload.dominios = selecionados.dominios;
      if (selecionados.categorias.length) payload.categorias = selecionados.categorias;
      if (allowOnlyNew && onlyNewInput.checked) payload.onlyNew = true;
      try {
        const resp = await fetch(url, { method: 'POST', headers: getExamAuthHeaders({ contentType: 'application/json', extra: { 'X-Exam-Type': currentExamType } }), body: JSON.stringify(payload) });
        const txt = await resp.text();
        let data; try { data = txt ? JSON.parse(txt) : null; } catch { data = null; }
        if (data && typeof data.available === 'number') return data.available;
        return null;
      } catch (_) { return null; }
    }

    // Contagem de inéditas independentemente do checkbox (para exibir potencial)
    async function countIneditasForCurrentFilters() {
      if (!allowOnlyNew) return null;
      const base = (BACKEND_BASE || '').replace(/\/$/, '');
      const url = base + '/api/exams/select';
      const token = getSessionToken();
      const payload = { count: 1, onlyCount: true, examType: currentExamType, onlyNew: true };
      if (selecionados.grupos.length) payload.grupos = selecionados.grupos;
      if (selecionados.dominios.length) payload.dominios = selecionados.dominios;
      if (selecionados.categorias.length) payload.categorias = selecionados.categorias;
      try {
        const resp = await fetch(url, { method: 'POST', headers: getExamAuthHeaders({ contentType: 'application/json', extra: { 'X-Exam-Type': currentExamType } }), body: JSON.stringify(payload) });
        const txt = await resp.text();
        let data; try { data = txt ? JSON.parse(txt) : null; } catch { data = null; }
        if (data && typeof data.available === 'number') return data.available;
        return null;
      } catch (_) { return null; }
    }

    // Debounced updater disponível globalmente para ser chamado ao clicar nos filtros
    scheduleAtualizarDisponiveis = debounce(async () => {
      const temFiltros = (selecionados.dominios.length + selecionados.grupos.length + selecionados.categorias.length) > 0;
      if (!temFiltros) { return; }
      try { resumoQtd.textContent = '...'; } catch(_){ }
      try { if (resumoQtdEscolhida) resumoQtdEscolhida.textContent = '...'; } catch(_){ }
      const disponiveis = await countForCurrentFilters();
      if (typeof disponiveis === 'number') {
        resumoQtd.textContent = String(disponiveis);
      }
      // Atualiza a quantidade que o usuário vai iniciar (considerando regras 15/50/180 e plano)
      try {
        const desired = resolveDesiredCount();
        const computed = computeFinalCount({ desired, available: (typeof disponiveis === 'number' ? disponiveis : null), hasFocos: true });
        if (resumoQtdEscolhida && computed && typeof computed.finalCount === 'number') {
          resumoQtdEscolhida.textContent = String(computed.finalCount);
        }
      } catch(_){ }
      // Atualiza indicador de inéditas
      try {
        resumoIneditas.textContent = '...';
        const ineditas = await countIneditasForCurrentFilters();
        if (typeof ineditas === 'number') resumoIneditas.textContent = String(ineditas);
        else resumoIneditas.textContent = '-';
        // Só mostrar contagem no texto do checkbox quando ele estiver marcado
        updateOnlyNewInfoText({ count: (typeof ineditas === 'number' ? ineditas : null), pending: false });
      } catch(e){ resumoIneditas.textContent='-'; }
    }, 300);

    // Try to rehydrate saved filters
    try {
      const raw = localStorage.getItem('examFilters');
      if (raw) {
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object') {
          if (Array.isArray(parsed.dominios)) selecionados.dominios = parsed.dominios.map(Number).filter(n=>!Number.isNaN(n));
          if (Array.isArray(parsed.grupos)) selecionados.grupos = parsed.grupos.map(Number).filter(n=>!Number.isNaN(n));
          if (Array.isArray(parsed.categorias)) selecionados.categorias = parsed.categorias.map(Number).filter(n=>!Number.isNaN(n));
          if (parsed.activeTab && (parsed.activeTab === 'dominios' || parsed.activeTab === 'grupos' || parsed.activeTab === 'abordagem')) abaAtual = parsed.activeTab;
          // Área de Conhecimento desativada: se veio salva como aba ativa, cai para Domínios
          if (parsed.activeTab === 'areas') abaAtual = 'dominios';
          if ((parsed.onlyNew === true || parsed.onlyNew === 'true') && allowOnlyNew) {
            try { onlyNewInput.checked = true; } catch(e){}
          }
        }
      }
    } catch(e) {}

    // Após reidratar estado do checkbox, ajustar o texto conforme marcado/desmarcado
    try {
      if (allowOnlyNew) {
        updateOnlyNewInfoText({ pending: !!(onlyNewInput && onlyNewInput.checked) });
      }
    } catch(_){ }

    function renderChecklist(items) {
      checklistDiv.innerHTML = '';
      const key = (abaAtual === 'abordagem') ? 'categorias' : abaAtual;
      const sel = selecionados[key] || [];
      items.forEach(item => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = item.descricao || item.label || String(item.id);
        btn.classList.add('check-btn');
        btn.setAttribute('data-id', String(item.id));
        if (sel.includes(Number(item.id))) btn.classList.add('active');
        btn.addEventListener('click', () => {
          const id = Number(btn.getAttribute('data-id'));
          const arr = selecionados[key] || (selecionados[key] = []);
          const idx = arr.indexOf(id);
          if (idx >= 0) { arr.splice(idx, 1); btn.classList.remove('active'); }
          else { arr.push(id); btn.classList.add('active'); }
          atualizarResumo();
          salvarSelecoes();
        });
        checklistDiv.appendChild(btn);
      });
    }

    async function atualizarResumo() {
      const filtrosSelecionados = (selecionados.dominios.length + selecionados.grupos.length + selecionados.categorias.length) > 0;
      // Disponibilidade só faz sentido quando há filtros; sem filtros, escondemos esse trecho.
      try {
        if (resumoAvailableWrap) resumoAvailableWrap.style.display = filtrosSelecionados ? '' : 'none';
        if (!filtrosSelecionados) resumoQtd.textContent = '-';
      } catch(_){ }

      // Quantidade que o usuário vai iniciar (imediata; com filtros, será refinada após a contagem)
      try {
        const desired = resolveDesiredCount();
        const computed = computeFinalCount({ desired, available: null, hasFocos: filtrosSelecionados });
        if (resumoQtdEscolhida) resumoQtdEscolhida.textContent = String((computed && typeof computed.finalCount === 'number') ? computed.finalCount : (desired || '-'));
      } catch(_){ }
      const labelMap = (list) => new Map((list || []).map(x => [Number(x.id), (x.descricao || x.label || String(x.id))]));
      const domMap = labelMap(meta.dominios);
      const grpMap = labelMap(meta.grupos);
      const catMap = labelMap(meta.categorias);

      const pickLabels = (map, ids) => (ids || [])
        .map((id) => map.get(Number(id)))
        .filter(Boolean);

      const domSel = pickLabels(domMap, selecionados.dominios);
      const grpSel = pickLabels(grpMap, selecionados.grupos);
      const catSel = pickLabels(catMap, selecionados.categorias);

      const parts = [];
      if (domSel.length) parts.push(`Domínio: ${domSel.join(' + ')}`);
      if (grpSel.length) parts.push(`Grupo de Processos: ${grpSel.join(' + ')}`);
      if (catSel.length) parts.push(`Abordagem: ${catSel.join(' + ')}`);

      resumoFocos.textContent = parts.length ? parts.join(' COM ') : 'Nenhum selecionado';
        // Atualiza a contagem disponível para os filtros (se houver)
        scheduleAtualizarDisponiveis();
      // Se houver acesso a inéditas e sem filtros, mostrar total geral (sem filtros)
      if (allowOnlyNew && !(selecionados.dominios.length + selecionados.grupos.length + selecionados.categorias.length)) {
        try {
          resumoIneditas.textContent = '...';
          updateOnlyNewInfoText({ pending: true });
          // consulta sem filtros
          const base = (BACKEND_BASE || '').replace(/\/$/, '');
          const url = base + '/api/exams/select';
          const token = getSessionToken();
          const payload = { count: 1, onlyCount: true, examType: currentExamType, onlyNew: true };
          const resp = await fetch(url, { method: 'POST', headers: getExamAuthHeaders({ contentType: 'application/json', extra: { 'X-Exam-Type': currentExamType } }), body: JSON.stringify(payload) });
          const txt = await resp.text();
          let data; try { data = txt ? JSON.parse(txt) : null; } catch { data = null; }
          if (data && typeof data.available === 'number') {
            resumoIneditas.textContent = String(data.available);
            updateOnlyNewInfoText({ count: data.available, pending: false });
          } else {
            resumoIneditas.textContent = '-';
            updateOnlyNewInfoText({ count: null, pending: false });
          }
        } catch(e){ resumoIneditas.textContent='-'; }
      }
    }

    // Atualiza contagens quando o checkbox de inéditas muda
    try {
      if (onlyNewInput && allowOnlyNew) {
        onlyNewInput.addEventListener('change', () => {
          try { salvarSelecoes(); } catch(_){ }
          try {
            if (onlyNewInput.checked) updateOnlyNewInfoText({ pending: true });
            else updateOnlyNewInfoText({ pending: false });
          } catch(_){ }
          try { atualizarResumo(); } catch(_){ }
          try { scheduleAtualizarDisponiveis(); } catch(_){ }
        });
      }
    } catch(_){ }

    function salvarSelecoes() {
      try {
        const payload = { dominios: selecionados.dominios, grupos: selecionados.grupos, categorias: selecionados.categorias, activeTab: abaAtual };
        if (allowOnlyNew) payload.onlyNew = !!onlyNewInput.checked;
        localStorage.setItem('examFilters', JSON.stringify(payload));
      } catch(e) {}
    }

    // Tab switching (Abordagem usa mesma checklist multi-seleção)
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        abaAtual = tab.dataset.aba;
        salvarSelecoes();
        if (abaAtual === 'dominios') renderChecklist(meta.dominios);
        else if (abaAtual === 'grupos') renderChecklist(meta.grupos);
        else if (abaAtual === 'abordagem') renderChecklist(meta.categorias);
        atualizarResumo();
      });
    });

    // Presets: manter apenas 1 marcado (comportamento tipo radio)
    try {
      qtdPresetInputs.forEach(inp => {
        inp.addEventListener('change', () => {
          ensureSinglePresetSelection(inp);
          try {
            const selected = getSelectedPresetCount();
            if (selected) localStorage.setItem('examQuestionCount', String(selected));
          } catch(_){ }
          atualizarResumo();
        });
      });
    } catch(_){ }

    function updateResumo(){ try { atualizarResumo(); } catch(e){} }

    function validateForm(){
      startError.style.display = 'none';
      // Agora a quantidade vem de presets (ou default). Sempre válido.
      return true;
    }

    function resolveDesiredCount(){
      // Se o usuário escolheu um preset, usar ele; caso contrário, usar default por perfil.
      const preset = getSelectedPresetCount();
      if (preset) return preset;
      return bloqueado ? 25 : (Number(limiteQuestoes) || FULL_Q);
    }

    function computeFinalCount({ desired, available, hasFocos }){
      let finalCount = Number(desired) || 0;
      const FULL_TARGET = Number(limiteQuestoes) || FULL_Q;

      if (hasFocos) {
        // Sem disponibilidade calculada ainda: mostrar o desejado (vai ser refinado após a contagem)
        if (typeof available !== 'number' || !Number.isFinite(available) || available < 0) {
          // aplicar apenas limites de plano/tipo para não exibir valores impossíveis
          if (bloqueado) finalCount = Math.min(finalCount || 25, getFreeUiLimit());
          else finalCount = Math.min(finalCount || FULL_TARGET, FULL_TARGET);
          return { finalCount, FULL_TARGET };
        }

        if (!bloqueado) {
          // Premium
          let cap = FULL_TARGET;
          if (available < 50) cap = 15;
          else if (available < FULL_TARGET) cap = 50;

          finalCount = Math.min(finalCount || cap, cap);
          if (finalCount < 15) finalCount = 15;
        } else {
          // Free
          finalCount = Math.min(finalCount || 25, getFreeUiLimit());
        }

        // Nunca pedir mais do que existe.
        finalCount = Math.min(finalCount, available);
      } else {
        // Sem filtros
        if (bloqueado) finalCount = Math.min(finalCount || 25, getFreeUiLimit());
        else finalCount = Math.min(finalCount || FULL_TARGET, FULL_TARGET);
      }

      return { finalCount, FULL_TARGET };
    }

    function showFullExamConfirm(onProceed){
      const modal = document.getElementById('fullExamConfirmModal');
      const proceedBtn = document.getElementById('fullExamProceed');
      const cancelBtn = document.getElementById('fullExamCancel');
      if (!modal || !proceedBtn || !cancelBtn) return false;
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden','false');
      const close = ()=>{ modal.style.display = 'none'; modal.setAttribute('aria-hidden','true'); };
      cancelBtn.onclick = ()=>{ close(); };
      proceedBtn.onclick = ()=>{ try{ close(); }catch(e){}; if (typeof onProceed==='function') onProceed(); };
      return true;
    }

    // Start button: validate, preflight, persist, and redirect (com confirmação para FULL_Q)
    startBtn.addEventListener('click', async () => {
      startError.style.display = 'none';
      const errorBox = document.getElementById('errorMsg');
      if (errorBox) errorBox.style.display = 'none';
      if (!validateForm()) return;

      const hasFocos = (selecionados.dominios.length + selecionados.grupos.length + selecionados.categorias.length) > 0;

      const desired = resolveDesiredCount();

      // Se houver filtros, precisamos saber quantas questões existem para aplicar as regras (15/50/full).
      let available = null;
      if (hasFocos) {
        available = await countForCurrentFilters();
        if (typeof available !== 'number' || available < 1) {
          if (errorBox) {
            errorBox.innerHTML = `Nenhuma questão encontrada para os filtros selecionados.`;
            errorBox.style.display = '';
          }
          return;
        }
      }

      const computed = computeFinalCount({ desired, available, hasFocos });
      const finalCount = computed && typeof computed.finalCount === 'number' ? computed.finalCount : (Number(desired) || 0);
      const FULL_TARGET = computed && typeof computed.FULL_TARGET === 'number' ? computed.FULL_TARGET : (Number(limiteQuestoes) || FULL_Q);

      // Faixa mínima para premium com filtros: 15
      if (!bloqueado && hasFocos && finalCount < 15) {
        if (errorBox) {
          errorBox.innerHTML = `O filtro selecionado tem poucas questões para iniciar um simulado (mínimo: 15).`;
          errorBox.style.display = '';
        }
        return;
      }

      // Persist flags
      try {
        if (allowOnlyNew) localStorage.setItem('examOnlyNewQuestions', onlyNewInput && onlyNewInput.checked ? 'true' : 'false');
      } catch(_){ }

      // Exame completo (FULL_TARGET) vai para tela dedicada.
      if (!hasFocos && !bloqueado && finalCount === FULL_TARGET) {
        showFullExamConfirm(() => {
          try {
            localStorage.setItem('examQuestionCount', String(finalCount));
            localStorage.setItem('examCountFromDefault', getSelectedPresetCount() ? 'false' : 'true');
          } catch(e) {}
          salvarSelecoes();
          try { sessionStorage.setItem('startExam', 'true'); } catch(e) {}
          (window.top || window).location.assign('/pages/examFull.html');
        });
        return;
      }

      try {
        localStorage.setItem('examQuestionCount', String(finalCount));
        localStorage.setItem('examCountFromDefault', getSelectedPresetCount() ? 'false' : 'true');
      } catch(e) {}
      salvarSelecoes();
      try { sessionStorage.setItem('startExam', 'true'); } catch(e) {}
      (window.top || window).location.assign('/pages/exam.html');
    });

    async function fetchJson(url){
      const resp = await fetch(url, { headers: getExamAuthHeaders({ acceptJson: true }) });
      if (!resp.ok) throw new Error(`GET ${url} -> ${resp.status}`);
      return await resp.json();
    }

    async function loadMeta(){
      try {
        const base = (BACKEND_BASE || '').replace(/\/$/, '');
        const [doms, grps, cats] = await Promise.all([
          fetchJson(base + '/api/meta/ddesempenho'),
          fetchJson(base + '/api/meta/grupos'),
          // Área de Conhecimento desativada
          // fetchJson(base + '/api/meta/areas'),
          fetchJson(base + '/api/meta/abordagens')
        ]);
        meta.dominios = Array.isArray(doms) ? doms : [];
        meta.grupos = Array.isArray(grps) ? grps : [];
        meta.categorias = Array.isArray(cats) ? cats : [];
      } catch (e) {
        logger.warn('Falha ao carregar metadados, usando listas vazias.', e);
        meta.dominios = meta.dominios || [];
        meta.grupos = meta.grupos || [];
        meta.categorias = meta.categorias || [];
      }

      // Sanear seleções persistidas para garantir que IDs existam nas listas atuais.
      try {
        const toValidIdSet = (list) => {
          const s = new Set();
          (list || []).forEach((x) => {
            const n = Number(x && x.id);
            if (Number.isFinite(n) && n > 0) s.add(n);
          });
          return s;
        };
        const validDom = toValidIdSet(meta.dominios);
        const validGrp = toValidIdSet(meta.grupos);
        const validCat = toValidIdSet(meta.categorias);

        selecionados.dominios = (selecionados.dominios || []).map(Number).filter((n) => Number.isFinite(n) && validDom.has(n));
        selecionados.grupos = (selecionados.grupos || []).map(Number).filter((n) => Number.isFinite(n) && validGrp.has(n));
        selecionados.categorias = (selecionados.categorias || []).map(Number).filter((n) => Number.isFinite(n) && validCat.has(n));
      } catch(e) {}

      try {
        const saved = localStorage.getItem('examQuestionCount');
        if (saved) {
          const n = Number(saved);
          // Se o valor salvo estiver entre os presets, reidratar seleção.
          if ([25,30,50,75,90].includes(n)) {
            setSelectedPresetCount(n);
          } else {
            // Caso contrário, não forçar seleção (premium pode cair no "exame completo" por padrão).
            if (bloqueado) setSelectedPresetCount(25);
            else clearPresetSelection();
          }
        }
      } catch(e) {}
      tabs.forEach(t => t.classList.remove('active'));
      const tabEl = document.querySelector(`.tab[data-aba="${abaAtual}"]`) || document.querySelector('.tab[data-aba="dominios"]');
      if (tabEl) tabEl.classList.add('active');
      if (abaAtual === 'dominios') renderChecklist(meta.dominios);
      else if (abaAtual === 'grupos') renderChecklist(meta.grupos);
      else if (abaAtual === 'abordagem') renderChecklist(meta.categorias);
      atualizarResumo();
    }

    async function loadExamTypes(){
      const base = (BACKEND_BASE || '').replace(/\/$/, '');
      try {
        const resp = await fetch(base + '/api/exams/types');
        const types = await resp.json();
        examTypeSelect.innerHTML = '';
        (types || []).forEach(t => {
          const opt = document.createElement('option');
          opt.value = t.id;
          // Exibir apenas o nome do exame (sem "X questões")
          opt.textContent = `${t.nome || t.id}`;
          examTypeSelect.appendChild(opt);
        });
        // restore selection
        if (currentExamType) examTypeSelect.value = currentExamType;
        // update constraints based on type
        const sel = (types || []).find(x => x.id === currentExamType) || (types || [])[0];
        if (sel) {
          // Ajuste limite máximo proporcional ao tipo; manter cap de 25 para bloqueado
          const maxByType = Number(sel.numeroQuestoes) || FULL_Q;
          limiteQuestoes = bloqueado ? Math.min(getFreeUiLimit(), maxByType) : maxByType;
          document.getElementById('limite-info').textContent = `(máx. ${limiteQuestoes})`;
          applyQuestionCountGate();
          try { localStorage.setItem('examBlueprint', JSON.stringify(sel)); } catch(e){}
        }
      } catch (e) {
        // fallback: ensure selection exists
        const opt = document.createElement('option');
        opt.value = currentExamType || 'pmp';
        // Fallback simples: mostrar apenas o nome
        opt.textContent = 'PMP';
        examTypeSelect.appendChild(opt);
      }
    }

    examTypeSelect.addEventListener('change', () => {
      currentExamType = examTypeSelect.value || 'pmp';
      try {
        const n = Number(currentExamType);
        if (Number.isFinite(n) && n > 0) {
          localStorage.setItem('examTypeId', String(Math.floor(n)));
          localStorage.setItem('examType', String(Math.floor(n)));
        } else {
          localStorage.setItem('examType', String(currentExamType).toUpperCase());
          localStorage.removeItem('examTypeId');
        }
      } catch(e){}
      // Reset quantity clamp on change
      const maxByType = (()=>{ try { const bp = JSON.parse(localStorage.getItem('examBlueprint')||'null'); return (bp && bp.numeroQuestoes) || FULL_Q; } catch(e){ return FULL_Q; } })();
      limiteQuestoes = bloqueado ? Math.min(getFreeUiLimit(), maxByType) : maxByType;
      document.getElementById('limite-info').textContent = `(máx. ${limiteQuestoes})`;
      applyQuestionCountGate();
      atualizarResumo();
      // examType muda o escopo da contagem
      scheduleAtualizarDisponiveis();
    });

    // Initialize currentExamType from query string or localStorage before loading options
    (function initExamTypeSelection(){
      try {
        const qs = new URLSearchParams(window.location.search);
        const qpId = qs.get('examTypeId');
        const qpSlug = qs.get('examType');
        const storedId = (localStorage.getItem('examTypeId')||'').trim();
        const stored = (localStorage.getItem('examType')||'').trim();
        // Priority: query examTypeId (numeric) → query examType (slug/id) → storedId → stored
        let candidate = qpId || qpSlug || storedId || stored || '';
        const n = Number(candidate);
        if (Number.isFinite(n) && n > 0) {
          currentExamType = String(Math.floor(n));
        } else if (candidate) {
          currentExamType = String(candidate).toLowerCase();
        }
      } catch(_){ }
    })();
    // Kick off: load types and restore selection to currentExamType
    loadExamTypes().then(() => {
      try {
        if (examTypeSelect && examTypeSelect.options && examTypeSelect.options.length > 1) {
          examTypeSelect.selectedIndex = 1; // select the second item (index 1)
          examTypeSelect.dispatchEvent(new Event('change'));
        }
      } catch(_) { }
    });
    // Abordagem agora usa mesma lógica de checklist multi-seleção (nenhum listener adicional necessário)
    loadMeta().then(() => {
      // Faça uma contagem inicial se já houver filtros salvos
      scheduleAtualizarDisponiveis();
    });
  </script>
  <!-- Bottom navigation component mount -->
  <div id="bottomNavMount"></div>
  <script>
    (function(){
      function loadBottomNav(){
        var mount = document.getElementById('bottomNavMount');
        if(!mount) return;
        fetch('../components/bottomNav.html')
          .then(function(r){ return r.ok ? r.text() : null; })
          .then(function(html){ if(html){
              mount.innerHTML = html;
              try {
                var scripts = Array.from(mount.querySelectorAll('script'));
                scripts.forEach(function(old){
                  var s = document.createElement('script');
                  if(old.src) s.src = old.src; else s.textContent = old.textContent || '';
                  old.parentNode.removeChild(old);
                  mount.appendChild(s);
                });
              } catch(_){ }
          } })
          .catch(function(){ /* silent */ });
      }
      if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', loadBottomNav); } else { loadBottomNav(); }
    })();
  </script>
  </body>
  </html>
